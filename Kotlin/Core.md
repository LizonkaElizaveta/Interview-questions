**1. КАК НУЖНО ОБЪЯВИТЬ ПЕРЕМЕННУЮ, ЧТОБЫ JVM НЕ СГЕНЕРИРОВАЛ БЫ ПОЛЕ, ДОПУСТИМ БЫЛ БЫ ТОЛЬКО GET?**
 
Ответ: 

```kotlin
val x: String
    get() = "Word"
```

**2. ЧТО ТАКОЕ NOTHING?**

Ответ: Это тип, у которого нет никаких значений и используется для того, чтобы обозначить те участки кода, которые могут быть не достигнуты никогда. В своём коде вы можете использовать Nothing для того, чтобы отметить функцию, чей результат никогда не будет возвращён:

```kotlin
fun fail(message: String): Nothing {
    throw IllegalArgumentException(message)
}
```
**3. ЧТО ТАКОЕ BACKING FIELD?**

Ответ: Классы в Kotlin не могут иметь полей. Т.е. переменные, которые вы объявляете внутри класса только выглядят и ведут себя как поля из Java, хотя на самом деле являются свойствами, т.к. для них неявно реализуются методы get и set. А сама переменная, в которой находится значение свойства, называется теневое поле (backing field).
Однако, иногда, при использовании пользовательских методов доступа, необходимо иметь доступ к теневому полю. Для этих целей Kotlin предоставляет автоматическое теневое поле, к которому можно обратиться с помощью идентификатора field:

```kotlin
var counter = 0
    set(value) {
        if (value >= 0) field = value // значение при инициализации записывается 
                                      // прямиком в backing field
    }
```

**4. КАК ОБРАТИТЬСЯ К ПЕРЕМЕННОЙ В JAVA, БЕЗ ГЕНЕРАЦИИ GET И SET?**

Ответ: Если вам нужно представить свойство Котлина в качестве поля в Java, вам нужно добавить к нему аннотацию @JvmField. Поле будет иметь такую же видимость, что и базовое свойство.Вы можете добавить свойству аннотацию @JvmField, если оно имеет backing field , не является приватным, не имеет open, override или const модификаторов и не является делегированным свойством.

```kotlin
class C(id: String) {
    @JvmField val ID = id
}
// Java
class JavaClient {
    public String getID(C c) {
        return c.ID;
    }
}
```

**5. ЧТО ПОД КАПОТОМ У LATEINIT?**

Ответ: проверка на null и выброс исключения throwUninitializedPropertyAccessException.

**6. КАК ПОНЯТЬ В КАКОМ СЛУЧАЕ НУЖНО ВЫБРАТЬ LATEINIT, А ГДЕ ВЫБИРАТЬ NULL?**

Ответ: Если хоть раз после инициализации значение переменной будет null, тогда нужно выбирать NULL.

**7. ЕСЛИ ВАШ KOTLIN-КОД СОВМЕСТИМ С JAVA-КОДОМ - КАК ОТОБРАЖАЮТСЯ В БАЙТ-КОДЕ JAVA ИНТЕРФЕЙСЫ, У КОТОРЫХ НЕТ ДЕФОЛТНЫХ МЕТОДОВ?**

Ответ: 

```java
// Kotlin
interface IFoo {

  fun populate() {
    print("Hello")
  }
}

// Java байт-код
public interface IFoo {

  void populate();
  
  public static final class DefaultImpls {
  
    public static void populate (IFoo $this) {
      String var1 = "Hello";
      System.out.println(var1);
    }
  }
}
```
**8. ЧТО ЗНАЧИТ ОДИН ВОСКЛИЦАТЕЛЬНЫЙ ЗНАК (!)?**

Ответ: Эта концепция была создана из соображений совместимости при доступе к коду с небезопасных платформ, таких как Java. Часто бывает так, что при использовании библиотеки Java многие методы возвращаютSomeType!, поскольку компилятор Kotlin не может определить, является ли результат обнуляемым или нет.

**9. ЧЕМ VAL ОТЛИЧАЕТСЯ ОТ CONST?**

Ответ: const s – константа времени компиляции. Это означает, что ее значение должно быть назначено во время компиляции, в отличие от val s, где это можно сделать во время выполнения. 

Константа никогда не может быть назначена функции или любому конструктору класса, только для String или примитива. Например

```kotlin
const val foo = complexFunctionCall()  // Not okay
val fooVal = complexFunctionCall()     // Okay

const val bar = "Hello world"   //Also okay
```

**10. ЗАЧЕМ НУЖЕН  COMPANION?**

Ответ: Классы в Kotlin не могут иметь статических членов, ключевое слово static не входит в состав языка. Можно пометить объект в классе ключевым словом companion вместе с другим ключевым словом object и обращаться к методам и свойствам объекта через имя содержащего его класса без явного указания имени объекта.

```kotlin
class Something{
	companion object {
		fun bar() {
			println("Companion object called")
		}
	}
}

Something.bar() // Companion object called
```

**11. ЧТО ТАКОЕ TYPE ALIAS?**

Ответ: Псевдонимы типов предоставляют альтернативные имена для существующих типов. Если имя типа слишком длинное, вы можете ввести другое более короткое имя и использовать вместо него новое.

```kotlin
typealias NodeSet = Set<Network.Node>
typealias FileTable<K> = MutableMap<K, MutableList<File>>
```
**12. Ключевые слова with, apply, also, run, let?**

**13. Что такое inline(), noinline(), crossinline() функции?**

**14. **
