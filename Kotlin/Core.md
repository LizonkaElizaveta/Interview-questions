**1. КАК НУЖНО ОБЪЯВИТЬ ПЕРЕМЕННУЮ, ЧТОБЫ JVM НЕ СГЕНЕРИРОВАЛ БЫ ПОЛЕ, ДОПУСТИМ БЫЛ БЫ ТОЛЬКО GET?**

Ответ: 

```kotlin
val x: String
    get() = "Word"
```

**2. ЧТО ТАКОЕ NOTHING?**

Ответ: Это тип, у которого нет никаких значений и используется для того, чтобы обозначить те участки кода, которые могут быть не достигнуты никогда. В своём коде вы можете использовать Nothing для того, чтобы отметить функцию, чей результат никогда не будет возвращён:

```kotlin
fun fail(message: String): Nothing {
    throw IllegalArgumentException(message)
}
```
**3. ЧТО ТАКОЕ BACKING FIELD?**

Ответ: Классы в Kotlin не могут иметь полей. Т.е. переменные, которые вы объявляете внутри класса только выглядят и ведут себя как поля из Java, хотя на самом деле являются свойствами, т.к. для них неявно реализуются методы get и set. А сама переменная, в которой находится значение свойства, называется теневое поле (backing field).
Однако, иногда, при использовании пользовательских методов доступа, необходимо иметь доступ к теневому полю. Для этих целей Kotlin предоставляет автоматическое теневое поле, к которому можно обратиться с помощью идентификатора field:

```kotlin
var counter = 0
    set(value) {
        if (value >= 0) field = value // значение при инициализации записывается 
                                      // прямиком в backing field
    }
```

**4. КАК ОБРАТИТЬСЯ К ПЕРЕМЕННОЙ В JAVA, БЕЗ ГЕНЕРАЦИИ GET И SET?**

Ответ: Если вам нужно представить свойство Котлина в качестве поля в Java, вам нужно добавить к нему аннотацию @JvmField. Поле будет иметь такую же видимость, что и базовое свойство.Вы можете добавить свойству аннотацию @JvmField, если оно имеет backing field , не является приватным, не имеет open, override или const модификаторов и не является делегированным свойством.

```kotlin
class C(id: String) {
    @JvmField val ID = id
}
// Java
class JavaClient {
    public String getID(C c) {
        return c.ID;
    }
}
```

**5. ЧТО ПОД КАПОТОМ У LATEINIT?**

Ответ: проверка на null и выброс исключения throwUninitializedPropertyAccessException.

**6. КАК ПОНЯТЬ В КАКОМ СЛУЧАЕ НУЖНО ВЫБРАТЬ LATEINIT, А ГДЕ ВЫБИРАТЬ NULL?**

Ответ: Если хоть раз после инициализации значение переменной будет null, тогда нужно выбирать NULL.

**7. ЕСЛИ ВАШ KOTLIN-КОД СОВМЕСТИМ С JAVA-КОДОМ - КАК ОТОБРАЖАЮТСЯ В БАЙТ-КОДЕ JAVA ИНТЕРФЕЙСЫ, У КОТОРЫХ НЕТ ДЕФОЛТНЫХ МЕТОДОВ?**

Ответ: 

```java
// Kotlin
interface IFoo {

  fun populate() {
    print("Hello")
  }
}

// Java байт-код
public interface IFoo {

  void populate();
  
  public static final class DefaultImpls {
  
    public static void populate (IFoo $this) {
      String var1 = "Hello";
      System.out.println(var1);
    }
  }
}
```
**8. ЧТО ЗНАЧИТ ОДИН ВОСКЛИЦАТЕЛЬНЫЙ ЗНАК (!)?**

Ответ: Эта концепция была создана из соображений совместимости при доступе к коду с небезопасных платформ, таких как Java. Часто бывает так, что при использовании библиотеки Java многие методы возвращаютSomeType!, поскольку компилятор Kotlin не может определить, является ли результат обнуляемым или нет.

**9. ЧЕМ VAL ОТЛИЧАЕТСЯ ОТ CONST?**

**10. ЗАЧЕМ НУЖЕН  COMPANION?**

**11. ЧТО ТАКОЕ TYPEALIAS?**
