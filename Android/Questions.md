**1. ЧТО ТАКОЕ APPLICATION?**

Ответ: Application - это базовый класс в приложении Android для поддержания глобального состояния приложения, который содержит все другие компоненты, такие как activities и services. Application или любой подкласс Application, создается перед любым другим классом при создании вашего приложения.

**2. ЧТО ТАКОЕ CONTEXT?**

Ответ: 

* **Context** -  интерфейс, предоставляющий глобальную информацию о среде приложения. Является абстрактным классом, реализация которого происходит с помощью Android-системы. Context позволяет получить доступ к ресурсам приложения и его классам, а также осуществлять вызовы операций на уровне приложения, например запуск Activity, Service, Broadcasting и Receiving intents, и тд.
* **Application Context** - этот контекст связан с жизненным циклом приложения. Application Context можно использовать там, где нужен контекст, жизненный цикл которого отделен от текущего контекста, или когда вы передаете контекст за пределы действия.
* **Activity Context** - этот контект доступен в activity и связан с жизненным циклом activity. Activity Context следует использовать, когда вы передаете контекст в области activity или вам нужен контекст, жизненный цикл которого привязан к текущему.

![](https://i.stack.imgur.com/sUSE6.png)

**3. ЧТО ТАКОЕ ARMV7?**

Ответ: В Andoroid есть 3 архитектуры процессора. ARMv7 является наиболее распространенным, посколько он оптимизирован для потребления батареи. ARM64 является усовершенствованной версией, которая поддерживает  64-битную обработку для более мощных вычислений. ARMx86, наименее используется из этих 3, так как потребляет много батареи, но является самой мощной.

**4. ПОЧЕМУ БАЙТ-КОД НЕ МОЖЕТ БЫТЬ ЗАПУЩЕН В ANDROID?**

Ответ:  Android использует DVM(Dalvek Virtual Machine), а не JVM(Java Virtual Machine). В версия Android 4.4 Kitkat имеется возможность переключится с Dalvik на ART(Android Runtime). В Android 5.0 Dalvik был полностью заменён на ART. В отличие от Dalvik, который использует JIT-компиляцию (во время выполнения приложения), ART компилирует приложение во время его установки. За счет этого планируется повышение скорости работы программ и одновременно увеличение времени работы от батареи. Недостатком является более долгая загрузка устройства.

**5. ЧТО ТАКОЕ BUILDTYPE В GRADLE? И ДЛЯ ЧЕГО ВЫ ЭТО МОЖЕТЕ ИСПОЛЬЗОВАТЬ?**

Ответ: Build types определяют свойства, которые Gradle использует при сборке и упаковке вашего Android-приложения. Build type определяет способ сборки(например, запускается ли ProGuard), какие ресурсы включены в сборку. Gradle может создать варианты сборки для различных комбинаций вашего проекта.

**6. ОБЪЯСНИТЕ ПРОЦЕСС СБОРКИ В ANDROID?**

Ответ: 

1. Первый шаг включает в себя компиляцию папки ресурсов(/res) с помощью инструмента aapt(android asset packaging tool). Создается класс R.java, который содержит константы.
2. Второй шаг заключается в том, что исходный код java компилируется в файлы .class с помощью javac. Затем файлы классов преобразуются в байт-код Dalvik с помощью инструмента "dx", которы вклчен в инструменты sdk. Выходными данными являются classes.dex.
3. Последний шаг включает в себя apkbuilder, который принимает все входные данные и создает apk(ключ упаковки Android).

**7. ЧТО ТАКОЕ АРХИТЕКТУРА ПРИЛОЖЕНИЙ В ANDROID?**

Ответ: Service, Intent, ContentProvider, BroadcastReciever

**8. ЧТО ТАКОЕ ACTIVITY?**

Ответ: Activity - окно пользовательского интерфейса.

**9. ОБЪЯСНИТЕ ЖИЗНЕННЫЙ ЦИКЛ ACTIVITY?**

Ответ: 

* OnCreate() - когда представление создается впервые;
* OnStart() - вызывается, когда activity становится видимой для пользователя. Затем следует onResume (), если activity выходит на передний план, или onStop (), если она становится скрытой;
* OnResume() - вызывается, когда activity начнет взаимодействовать с пользователем. На данный момент ваша активность находится на вершине стека активностей;
* OnPause() - вызывается, когда activity переходит в фоновый режим, но еще не была уничтожена;
* OnStop() - вызывается, когда activity больше не видна пользователю;
* OnDestroy() - вызывается, когда activity завершилась;
* OnRestart() - будет вызываться всякий раз, когда активность возвращается из невидимого состояния.

![](https://i.stack.imgur.com/kUtt7.png)

**10. КАКИЕ РАЗЛИЧИЯ МЕЖДУ ONCREATE() И ONSTART()?**

Ответ: Метод onCreate () вызывается один раз в течение жизненного цикла activity, либо при запуске приложения, либо когда activity было уничтожено и затем воссоздано, например, во время изменения конфигурации. Метод onStart () вызывается всякий раз, когда activity становится видимой для пользователя, обычно после onCreate () или onRestart ().

**11. СЦЕНАРИЙ, В КОТОРОМ ВЫЗЫВАЕТСЯ ONDESTROY() ДЛЯ ACTIVITY БЕЗ ONPAUSE() И ONSTOP()?**

Ответ: Если в методе OnCreate() вызывается метод finish(), система напрямую вызывает метод OnDestroy().

**12. ПОЧЕМУ СЛЕДУЕТ ВЫЗЫВАТЬ МЕТОД SETCONTENTVIEW() В МЕТОДЕ ONCREATE()?**

Ответ: Посколько метод OnCreate() вызывается только один раз, это место, где должна выполняться большая часть инициализации. Неэффективно устанавливать содержимое в OnResume() или OnStart()(которые вызываются несколько раз), т.к. операция setContentView() - является тяжеловесной.

**13. ЧТО ДЕЛАЮТ МЕТОДЫ ONSAVEDINSTANCESTATE() И ONRESTOREINSTANCESTATE() В ACTIVITY?**

Ответ: 

* **OnSavedInstanceState()** - вызывается, когда нужно зафиксировать состояние активности перед её уничтожением. Метод вызывается перед методом OnPause(). Он предоставляет возможность сохранять состояние пользовательского интерфейса активности в объект Bundle, который потом будет передаваться в методы OnCreate() и OnRestoreInstanceState(). Когда активность будет снова вызвана, объект Bundle передается системой в качестве параметра в методы OnCreate() и OnRestoreInstanceState(). Система Android не вызывает этот метод, когда нажата клавиша BACK, либо вызван метод finish().
* **OnRestoreInstanceState()** - когда активность воссоздается после того, когда она была уничтожена, мы можем можем восстановить сохраненное состояние. Метод получает объект Bundle(), содержащий информацию о состоянии экземпляра.

**14. КАКИЕ РЕЖИМЫ ЗАПУСКА В ANDROID(ИСПОЛЬЗУЯ АТРИБУТ LAUNCHMODE)?**

Ответ: При объявлении операции в вашем файле манифеста вы можете указать, как операция должна быть связана с задачей посредством атрибута launchMode.

* **standart** - создает новый экземпляр операции в задаче, из которой она была запущена, и направляет ему намерение. Может быть создано несколько экземпляров операции, каждый экземпляр может принадлежать различным задачам, и одна задача может содержать несколько экземпляров. Например, есть стек *A -> B -> C*. Если снова запустить *B* в режиме запуска *standart*, новый стек будет *A -> B -> C -> B*.

* **singleTop** - если экземпляр операции уже существует на вершине текущей задачи, система направляет намерение в этот экземпляр путем вызова его метода onNewIntent(), а не путем создания нового экземпляра операции. Например, есть стек *A -> B -> C*. Если запустить *С* в режиме запуска *singleTop*, стек будет *A -> B -> C*. Однако, если поступает намерение от операции *B* в режиме *singleTop*, то в стек добавлятся новый экземпляр *A -> B -> C -> B*, независимо от режима *singleTop*.

* **singleTask** - система создает новую задачу и создает экземпляр операции в корне новой задачи.  Однако, если экземпляр операции уже существует в отдельной задаче, система направляет намерение в существующий экземпляр путем вызова его метода onNewIntent(). Одновременно может существовать только один экземпляр операции. Например, есть стек *A -> B -> C -> D*. Если снова запустить *D* в режиме запуска *singleTask*, новый стек будет *A -> B -> C -> D*. Однако, если поступает намерение от операции *B* в режиме *singleTask*, то новый стек будет *A -> B*. Операции *C* и *D* будут уничтожены.

* **singleInstance** - cистема не запускает никаких других операций в задаче, содержащей этот экземпляр. Операция всегда является единственным членом своей задачи; любые операции, запущенные этой операцией, открываются в отдельной задаче. Например, есть стек *A -> B -> C -> D*. Если снова запустить *D* в режиме запуска *singleInstance*, то Задача1 = *A -> B -> C* и Задача2 = *D*. 

**15. КАК ПРЕДОТВРАТИТЬ ПЕРЕЗАГРУЗКУ И СБРОС ДАННЫХ ПРИ ПОВОРОТЕ ЭКРАНА?**

Ответ: С помощью комбинации ViewModel и onSavedInstanceState().
Например, допустим у нас есть экран поиска. Пользователь вводит запрос в EditText. Результат отображается в RecyclerView. Когда конфигурация экрана меняется, то идеальным вариантом для предотвращения сброса данных - сохранение списка элементов в ViewModel, а запрос пользователя в OnSavedInstanceState(). 

**16. КАКИЕ ДВА СПОСОБА ОЧИСТИТЬ ЗАДНИЙ СТЕК ACTIVITIES, КОГДА ВЫЗЫВАЕТСЯ НОВАЯ ACTIVITY С ПОМОЩЬЮ INTENT?**

Ответ: Использовать флаги FLAG_ACTIVITY_CLEAR_TOP, FLAG_ACTIVITY_CLEAR_TASK и FLAG_ACTIVITY_NEW_TASK в качестве конъюкции.

**17. КАКАЯ РАЗНИЦА МЕЖДУ ФЛАГАМИ FLAG_ACTIVITY_CLEAR_TOP И FLAG_ACTIVITY_CLEAR_TASK?**

Ответ: 

* **FLAG_ACTIVITY_CLEAR_TASK** - задача для вызываемой операции будет очищена, а вызываемая операция станет в ней корневой.
* **FLAG_ACTIVITY_CLEAR_TOP** - ищет в задаче создаваемую операцию. Если находит, то открывает, а все, что выше – закрывает.

**18. КАК РЕАГИРУЕТ ACTIVITY, КОГДА ПОЛЬЗОВАТЕЛЬ ПЕРЕВОРАЧИВАЕТ ЭКРАН?**

Ответ: Когда экран поворачивается, текущий экземпляр activity уничтожается, создается новый экземпляр activity в новой ориентации. Метод onRestart () вызывается первым при повороте экрана. Другие методы жизненного цикла вызываются в том же потоке, что и при первом создании activity.

**19. ОПИШИТЕ CONTENT PROVIDER?**

Ответ: ContentProvider предоставляет данные из одного приложения в другое по запросу. Он управляет доступом к структурированному набору данных и предоставляет механизмы для обеспечения безопасности данных. ContentProvider - интерфейс, который связывает данные в одном процессе с кодом, выполняющимся в другом процессе. Если вы хотите получить данные, то нужно использовать ContentResolver в контексте вашего приложения. Объект провайдера получает запросы данных от клиентов, выполняет запрос и возвращает результаты.

**20. ДОСТУП К ДАННЫМ С ПОМОЩЬЮ CONTENT PROVIDER?**

Ответ: Для начала следует убедится, что у вашего приложения есть необходимые разрешения на чтение. Затем нужно получить доступ к ContentResolver, вызвав метод getContentResolver(), создать запрос с помощью ContentResolver.query(). Метод ContentResolver.query() возвращает курсор, поэтому данные можно извлекать из столбцов с помощью мемтодов курсора.

**21. Serializable vs Parcelable**

Serializable - это стандартный Java-интерфейс. Вы просто отмечаете класс Serializable, реализуя интерфейс, и Java будет автоматически сериализовать его в определенных ситуациях.
Parcelable - это специфический для Android интерфейс, где вы сами реализуете сериализацию. Он был создан более эффективным, чем Serializable, а также для обхода некоторых проблем со схемой сериализации Java по умолчанию.

**22. Виды Intent**

явные(например, запустить новую активити), неявные(например запустить почту, передаем параметр и система выдает нам предложенные варианты почты). 

**23. addOnBackStackChangeListener**

Для управления фрагментами в операции нужен класс FragmentManager. Чтобы получить его, следует вызвать метод getFragmentManager() из кода операции.

Ниже указаны действия, которые позволяет выполнитьFragmentManager:

получать фрагменты, имеющиеся в операции, с помощью метода findFragmentById() (для фрагментов, предоставляющих пользовательский интерфейс в макете операции) или findFragmentByTag() (как для фрагментов, имеющих пользовательский интерфейс, так и для фрагментов без него);
снимать фрагменты со стека переходов назад методом popBackStack() (имитируя нажатие кнопки Назад пользователем);
регистрировать процесс-слушатель изменений в стеке переходов назад при помощи метода addOnBackStackChangedListener().

**24.Dialog vs DialogFragment**

dialog - отображение диалога, старая фигня, креши при повороте экрана. DialogFragment – фрагмент, который содержит внутри себя объект Dialog и выступает как интерфейс для взаимодействия с диалогом. У DialogFragment жизненный цикл фрагмента. Система сама заботится о пересоздании DialogFragment при configuration changes.

**25. MVC, MVP, MVVM, MVI**

**26. LiveData (value vs postValue, active() vs onInactive(), MediatorLiveData)**

**27. ViewModel, Room, Realm(БД)**

**28. Spannable**

фигня для слепливания текста, картинок, ссылок и помощь в сложной верстке

**29. setRetainInstance in fragment — что даёт?**

у фрагмента есть свойство retainInstance, которое по умолчанию содержит значение false и при поворотах фрагмент не сохраняется, а уничтожается и создается заново вместе с активностью. setRetainInstance(true) сохраняет фрагмент, который не уничтожается вместе с активностью, а передается новой активности в неизменном виде

**30. AsyncTask — для чего и какие имеет недостатки?**

AsyncTask не привязан к жизненному циклу Activity, который его содержит. Например, если вы запускаете AsyncTask внутри Activity и пользователь поворачивает устройство, активность будет уничтожена (и будет создан новый экземпляр Activity), но AsyncTask останется целым и продолжит работать до завершения.

Затем, когда AsyncTask завершает работу, вместо обновления UI новой Activity, он обновляет прежний экземпляр Activity (то есть тот, в котором он был создан, но который больше не отображается!). Это может привести к исключению (типа java.lang.IllegalArgumentException: View не подключен к оконному менеджеру, если вы используете, например, findViewByIdдля получения представления внутри Activity).

Также существует вероятность того, что это приведет к утечке памяти, так как AsyncTask поддерживает ссылку на Activity, что предотвращает сбор мусора, пока AsyncTask остается в живых.
По этим причинам использование AsyncTasks для длительных фоновых задач, как правило – плохая идея. Для них должен использоваться другой механизм (например, служба).

**31. Bundle**

для временного хранения данных 

**32. Метод invalidate() in view — как работает?**
https://itsobes.ru/AndroidSobes/v-chem-raznitsa-mezhdu-invalidate-i-requestlayout/

**33. Реализация сustom View и custom ViewGroup. Отличия в реализациях;**

**34. Handler, Looper, MessageQueue**

https://stackofskills.com/android-interview-7-threads/

**35. Типы сервисов (запущенный, привязанный, IntentService), их отличия и жизненные циклы;**

запущенная -  компонент сервис запускается вызовом метода Context.startService(intent) и завершается с помощью stopService()(может также остановить себя сама), привязанный - Context.bindService(intent,serviceConnection, int) взыимодействует через интерфейс ServiceConnection и в любой момент может разорвать свзять, т.е. привязывается к уже готовой службе

Подобно активностям служба имеет свои методы жизненного цикла:

onCreate()
onStartCommand()
onDestroy()

**36. Опишите три общих варианта использования Intent**

Общие варианты использования Intent:

Чтобы начать действие : вы можете запустить новый экземпляр Activity, передав Intent методу startActivity().
Чтобы запустить службу: вы можете запустить службу для выполнения одноразовой операции (например, скачать файл), передав Intent вstartService().
Для трансляций : Вы можете отправить трансляцию другим приложениям, передавав Intent вsendBroadcast(), sendOrderedBroadcast()или sendStickyBroadcast().

**37. В чем разница между фрагментом и активностью? Объясните взаимосвязь между ними.**

Активность , как правило, одиночная, целенаправленная операция, которую может выполнять пользователь (например, набрать номер, сделать снимок, отправить email, просматривать карту, и т.д.). Но в то же время нет ничего, что помешало бы разработчику произвольно создать сложную активность.

Реализации активности могут дополнительно использовать класс Fragment для создания более модульного кода, более сложных пользовательских интерфейсов для больших экранов, помощи в масштабировании приложения между малыми и большими экранами и т. д. Несколько фрагментов могут быть объединены в пределах одной активности, и, наоборот, один и тот же фрагмент часто можно использовать повторно для нескольких активностей. Эта структура в основном предназначена для содействия повторному использованию кода и облегчению масштабирования.

Фрагмент представляет собой модульный раздел активности с собственным жизненным циклом и входными событиями, который может быть добавлен или удален по желанию. Однако важно помнить, что жизненный цикл фрагмента напрямую зависит от жизненного цикла его хост-активности; т. е. когда активность приостановлена, все фрагменты в ней также будут приостановлены, и когда активность разрушена, все ее фрагменты будут разрушены.

**38. В чем разница между Service и IntentService? Как они используются?**

Service является базовым классом для служб Android, который может быть расширен для создания любой из них. Класс, который напрямую расширяет Service запускается в основном потоке. По этой причине он блокирует UI (если он есть) и должен использоваться только для кратковременных задач. Для более длительных задач лучше использовать другие потоки.

IntentService является подклассом Service, который обрабатывает асинхронные запросы (выраженные как «Intent») по требованию. Клиенты отправляют запросы через вызовы startService(Intent). Служба запускается по мере необходимости, по очереди обрабатывает каждую Intent с помощью рабочего потока и останавливается, когда заканчивается работа. Написание IntentServiceможет быть довольно простым; просто расширьте класс IntentService и переопределите метод onHandleIntent(Intent intent), в котором вы можете управлять всеми входящими запросами.

