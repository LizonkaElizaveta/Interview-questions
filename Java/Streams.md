**1. КАКАЯ РАЗНИЦА МЕЖДУ I/O И NIO?**

Ответ: I/O - ввод/вывод данных. NIO - Non-blocking I/O, New IO, высокопроизводительные операции ввода/вывода.

IO | NIO
--- | --- |
Потокоориентированный | Буфер-ориентированный
Блокирующий (синхронный) ввод/вывод	| Неблокирующий (асинхронный) ввод/вывод
-| Селекторы 


**2. КАКИЕ ОСОБЕННОСТИ NIO ВЫ ЗНАЕТЕ?**

Ответ: 

* Каналы и селекторы: NIO поддерживает различные типы каналов. Канал является абстракцией объектов более низкого уровня ФС, что позволяет передавать данные с более высокой скоростью. Каналы не блокируются и поэтому Java предоставляет еще такие  инструменты, как селектор, который позволяет выбрать готовый канал для передачи данных, и сокет, который является инструментом для блокировки;
* Буферы: в Java 7 была введена буферизация для всех классов-оберток примитивов(кроме Boolean). Появился абстрактный класс BUffer, который представляет такие операции как clear, flip, mark;
* Кодировки: в Java 7 появились кодировки(java.nio.charset), кодеры и декодеры для отображения байт и символов Unicode.

**3. КАКИЕ СУЩЕСТВУЮТ ПОТОКИ ВВОДА/ВЫВОДА?**

Ответ: 

![](https://2.bp.blogspot.com/-5boKm8RgEjI/Vq4BL8MzB_I/AAAAAAAAAN8/VsFyzmbs6_Q/s1600/input_output_stream.jpg)

**4. КАКИЕ ПОДКЛАССА БАЗОВОГО КЛАССА INPUTSTREAM ВЫ ЗНАЕТЕ, ДЛЯ ЧЕГО ОНИ ПРЕДНАЗНАЧЕНЫ?**

Ответ: 

* StringBufferInputStream - превращает строку во входной поток данных InputStream;
* SequenceInputStream - сливает 2 или более потока InputStream в единый поток;
* PushBackInputStream - входной поток,поддерживающий однобайтовый возврат во входной поток;
* PrintStream - выходной поток, включающий метода print() и println();
* PipedInputSream - реализует понятие входного канала;
* ObjectInputStream - входной поток для объектов;
* FilterInputStream - абстрактный класс, предоставляющий интерфейс для классов-надстроек, который добавляют к существующим  потокам полезные свойства;
* FileInputStream - для чтения информации из файла;
* DataInputStream - входной поток, включающий методы для чтения стандартных типов данных;
* ByteArrayInputStream - позволяет использовать буфер в памяти(массив байтов) в качестве источника данных для входного потока;
* BufferedInputStream - буферизированный входной поток.

**5. ЧТО ВЫ ЗНАЕТЕ О RANDOMACCESSFILE?**

Ответ: RandomAccessFile это класс, который наследуется напрямую от Object и не наследуется от вышеприведенных базовых классов ввода/вывода. Предназначен для работы с файлами, поддерживая произвольный доступ к их содержимому.

Работа с классом RandomAccessFile напоминает использование совмещенных в одном классе потоков DataInputStream и DataOutputStream. Кроме того, метод seek() позволяет переместиться к определенной позиции и изменить хранящееся там значение. 

При использовании RandomAccessFile  необходимо знать структура файла.

**6. КАКИЕ ЕСТЬ РЕЖИМЫ ДОСТУПА К ФАЙЛУ У RANDOMACCESSFILE?**

Ответ: RandomAccessFile может открываться в режиме чтения("r") или чтения/записи("rw"). Также есть режим "rws", когда файл открывается для операций чтения-записи и каждое изменение данных файла немедленно записывается на физическое устройство.

**7. ДЛЯ ЧЕГО ИСПОЛЬЗУЕТСЯ PUSHBACKINPUTSTREAM?**

Ответ: Класс PuchbackInputStream представляет механизм "заглянуть" во входной поток и увидеть, что оттуда поступит в следующий раз, не извлекая информации. У класса есть дополнительный метод unread().

**8. ДЛЯ ЧЕГО ИСПОЛЬЗУЕТСЯ SEQUENCEINPUTSTREAM?**

Ответ: Класс SequenceInputStream позволяет соединять вместе несколько экземпляром класса InputStream. Конструктор принимает в качестве аргументов либо пару объектов класса InputStream, либо интерфейс Enumeration.

Во время работы класс выполняет запросы на чтение  из первого объекта класса InputStream и до конца, а затем переключается на второй. При использовании интерфейса работа продолжится по всем объектам класса InputStream. По достижении конца каждого файла, связанный с ним поток закрывается. Закрытие потока, созданного объектом класса SequenceInputStream, приводит к закрытию всех открытых потоков.

**9. КАКИЕ ПОДКЛАССЫ БАЗОВОГО КЛАССА READER ВЫ ЗНАЕТЕ, ДЛЯ ЧЕГО ОНИ ПРЕДНАЗНАЧЕНЫ?**

Ответ: 

* StringReader - входной поток, читающий из строки;
* Reader - абстрактный класс, описывающий символьный ввод;
* PushbackReader - входной поток, позволяющий возвращать обратно символы в поток;
* PipedReader - входной канал;
* LineNumberReader - входной поток, подсчитывающий строки;
* InputStreamReader - входной поток, транслирующий байты в символы;
* FilterReader - фильтрующий читатель;
* FileReader - входной поток, читающий файл;
* CharArrayReader - входной поток, который читает из символьного массива;
* BufferedReader -  буферизированный входной символьный поток.

**10. КАКИЕ ПОДКЛАССЫ БАЗОВОГО КЛАССА OUTPUSTREAM ВЫ ЗНАЕТЕ, ДЛЯ ЧЕГО ОНИ ПРЕДНАЗНАЧЕНЫ?**

Ответ: 

* PipedOutputSream - реализует понятие выходного канала;
* ObjectOutputSream - выходной поток для объектов;
* FilterOutputSream - абстрактный класс, предоставляющий интерфейс для классов-надстроек, который добавляют к существующим  потокам полезные свойства;
* FileOutputSream - отправка данных в файл на диск;
* DataOutputSream - выходной поток, включающий методы для записи стандартных типов данных;
* ByteArrayOutputSream - создает буфер в памяти. Все данные, посылаемые в этом поток, размещаются в созданном буфере;
* BufferedOutputSream - буферизированный выходной поток.

**11.  КАКИЕ ПОДКЛАССЫ БАЗОВОГО КЛАССА WRITER ВЫ ЗНАЕТЕ, ДЛЯ ЧЕГО ОНИ ПРЕДНАЗНАЧЕНЫ?**

Ответ: 

* StringWriter - выходной поток, пишущий в строку;
* Writer - абстрактный класс, описывающий символьный вывод;
* PipedWriter - выходной канал;
* PrintWriter - выходной поток, включающий методы print() и println();
* OutputStreamWriter - выходной поток, транслирующий байты в символы;
* FilterWriter - фильтрующий писатель;
* FileWriter - выходной поток, пишущий в файл;
* CharArrayWriter - выходной поток, который пишет в символьный массив;
* BufferedWriter -  буферизированный выходной символьный поток.

**12. ЧТО ТАКОЕ АБСОЛЮТНЫЙ И СИМВОЛЬНЫЙ ПУТЬ?**

Ответ: Абсолютный путь - это путь, который указывает на одно и тоже место в ФС, вне зависимости от текущей директории.

Относительный путь - это путь по отношению к текущему рабочему каталогу.

**13. В КАКИХ ПАКЕТАХ ЛЕЖАТ КЛАССЫ-ПОТОКИ?**

Ответ: java.io.* , java.nio.* , java.util.*(для работы с архивами).

**14. ЧТО ВЫ ЗНАЕТЕ О КЛАССАХ-НАДСТРОЙКАХ?**

Ответ: Классы-надстройки - это классы, которые   добавляют к существующим потокам полезные дополнительные свойства.

**15. КАКОЙ КЛАСС-НАДСТРОЙКА ПОЗВОЛЯЕТ ЧИТАТЬ ДАННЫЕ ИЗ ВХОДНОГО БАЙТОВОГО ПОТОКА В ФОРМАТЕ ПРИМИТИВНЫХ ТИПОВ ДАННЫХ?**

Ответ: DataInputStream.

**16. КАКИЕ КЛАССЫ-НАДСТРОЙКИ ПОЗВОЛЯЮТ УСКОРИТЬ ЧТЕНИЕ/ЗАПИСЬ ЗА СЧЕТ ИСПОЛЬЗОВАНИЯ БУФЕРА?**

Ответ: BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriter.

**17. КАКИЕ КЛАССА ПОЗВОЛЯЮТ ПЕРОБРАЗОВАТЬ БАЙТОВЫЕ ПОТОКИ В СИМВОЛЬНЫЕ И ОБРАТНО?**

Ответ: OutputStreamWriter - это мост между классом  OutputStream и классом Writer.

![](https://1.bp.blogspot.com/-T99_yEt1bCw/Vq4BY-zQQ6I/AAAAAAAAAOE/IkbM3I-7ziA/s1600/OutputStream_example.jpg)

InputStreamReader - аналог чтения. При помощи методов класса Reader читаются байты из потока InputStream и далее преобразуются в символы.

![](https://3.bp.blogspot.com/-qWMY1eQ9gSg/Vq4BdC2oWYI/AAAAAAAAAOM/Ugck__wA1GY/s1600/InputStream_example.jpg)

**18. В ЧЕМ ОТЛИЧИЕ В КЛАССЕ PRINTWRITER ОТ PRINTSTREAM?**

Ответ: PrintStream печатает в OutputStream, а PrintWriter печатает в Writer.  Оба являются потоками, с основным отличием в том, что OutputStream - это поток байтов, а Writer - это поток символов.

PrintStream преобразует символы в байты, используя кодировку платформы по умолчанию. Использование кодировки по умолчанию, как правило, плохо, так как это может привести к ошибкам при переходе с одной платформы на другую, особенно если вы генерируете файл на одной платформе и используете его на другой. При использовании Writer вы обычно указываете используемую кодировку, избегая любых зависимостей платформы.

С PrintStream вы придерживаетесь стандартного кодирования платформы.
``` java
PrintStream stream = new PrintStream(output);
```
С PrintWriter вы можете передать OutputStreamWriter с определенным кодированием.
```java
PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, "UTF-8"));
```

**19. КАКОЙ КЛАСС ПРЕДНАЗНАЧЕН ДЛЯ РАБОТЫ С ФАЙЛОВОЙ СИСТЕМОЙ?**

Ответ: java.io.File. Для создания объектов класса File, можно использовать один из следующий конструкторов:

* File(File dir, String name) - указывается объект класса File и имя файла;
* File(String path) - указывается путь к файлу без указания имени файла;
* File(String dirPath, String name) - указывается путь к файлу и имя файла;
* File(UPI url) - указывается объект URI, описывающий файл.

**20. КАКОЙ СИМВОЛ ЯВЛЯЕТСЯ РАЗДЕЛИТЕЛЕМ ПРИ УКАЗАНИИ ПУТИ В ФАЙЛОВОЙ СИСТЕМЕ?**

Ответ: Для различных  систем символ разделителя различается. Вытащить его можно используя file.separator. Для Windows это "\".

**21. КАКИЕ МЕТОДЫ КЛАССА FILE ВЫ ЗНАЕТЕ?**

Ответ: 

* getAbsolutePath
* canRead()
* canWrite()
* exists()
* getName()
* getParent()
* getPath()
* lastModified()
* isFile()
* isDirectory()
* isAbsolute()
* renameTo(File newPath)
* delete()

**22. ЧТО ВЫ ЗНАЕТЕ ОБ ИНТЕРФЕЙСЕ FILEFILTER?**

Ответ: Интерфес FileFilter применяется  для проверки, попадает ли объект File под некоторое условие. Этот интерфейс содержит единственный метод boolean accept(File pathName). Этот метод необходимо переопределить  и реализовать.

**23. КАКИЕ КЛАССЫ ПОЗВОЛЯЮТ АРХИВИРОВАТЬ ОБЪЕКТЫ?**

Ответ: DeflaterOutputStream, InflaterOutputStream, ZipInputStream, GZIPInputStream, GZIPOutputStream.