**1. Что такое Heap и Stack память в Java?**

Ответ: Java Heap - динамически распределяемая область памяти, создаваемая при старте JVM. Все объекты обитают в куче и попадают туда при создании. Здесь работает сборщик мусора(освобождает память путем удаления объектов, на которые нет каких-либо ссылок). Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения.

Стековая память в Java работает по схеме LIFO (Последний-зашел-Первый-вышел). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче.

**2. Какая разница между Stack и Heap памятью в Java?**

Ответ:  
* Куча используется всеми частями приложения в то время как стек используется только одним потоком исполнения программы.

* Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.

* Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.

* Управление памятью в стеке осуществляется по схеме LIFO.

* Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.

* Мы можем использовать -Xms и -Xmx опции JVM, чтобы определить начальный и максимальный размер памяти в куче. Для стека определить размер памяти можно с помощью опции -Xss .

* Если память стека полностью занята, то Java Runtime бросает java.lang.StackOverflowError, а если память кучи заполнена, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.

* Размер памяти стека намного меньше памяти в куче. Из-за простоты распределения памяти (LIFO), стековая память работает намного быстрее кучи.

**3. Расскажите про модель памяти в Java?**

Ответ: В Java память устроена следующим образом:

![](https://www.yourkit.com/docs/kb/jvm_memory_structure.gif)

В куче хранятся все экземпляры классов и массивов. Куча создается при запуске JVM и может увеличиваться или уменьшаться в размере во время работы приложения. Куча может иметь фиксированный или переменный размер в зависимости от стратегии сбора мусора. По умолчанию размер кучи составляет 64 MB.

Память без кучи создается при запуске JVM и хранит структуры для каждого класса такие как: пул констант времени выполнения, данные полей и методов, а также код для методов и конструкторов и интернированные строки (хранение одной копии из множества одинаковых). По умолчанию размер памяти без кучи составляет 64 MB.

Other - JVM использует это пространство для хранения самого кода JVM, внутренних структур JVM, загруженного кода и данных агента профилировщика(сбор характеристик работы программы, таких как время выполнения отдельных фрагментов, число верно предсказанных условных переходов, число кэш-промахов и т. д.)

JVM куча физически делится на 2 части(поколения): молодое и старое.

В Eden Space выделяется память под все создаваемые из программы объекты. Большая часть объектов живет недолго у даляются при сборке мусора, и не перемещаются в другие области памяти. Когда данная область заполняется, GC выполняет быструю (minor collection) сборку мусора. По сравнению с полной сборкой мусора, она занимает мало времени,  и затрагивает только эту область памяти - очищает от устаревших объектов Eden Space и перемещает выжившие объекты в следующую область.

Survivor Space -  сюда перемещаются объекты из предыдущей части, после того как они пережили хотя бы одну сборку мусора. В одно время пространство для выживших всегда пусто. Объекты, которые пережилинесколько циклов GC, перемещаются в старое поколение.

Когда старое поколение становится заполненным, то вызывается полная сборка мусора, которая затрагивает больше времени.

Permanent Generatiom содержит метаданные приложения, требуемые JVM для описания классов и методов, используемых в приложении, а также библиотеки Java SE. Начиная с Java 8 вместо Perm Gen используется Metaspace, который не является частью кучи. Metaspace имеет возможность динамически расширятся, органиченная по умолчанию только размером нативной памяти.

![](https://i2.wp.com/betsol.com/wp-content/uploads/2017/06/java-memory-management-1.jpg?resize=1024%2C425&ssl=1)

![Java Memory Model](https://cdn-images-1.medium.com/max/800/1*YhrLZsWIzmSyH-6FYlndAA.png)

**4.   Как работает cборщик мусора?**

Ответ: Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора.

**Serial(последовательный) GC** - самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.

При использовании данного сборщика куча разбивается на четыре региона, три из которых относятся к младшему поколению (Eden, Survivor 0 и Survivor 1), а один (Tenured) — к старшему:

![](https://hsto.org/files/6b0/3a9/e6d/6b03a9e6d8174da3a7b228eb9acbe001.png)

Среднестатистический объект начинает свою жизнь в регионе Eden (объекты-акселераты, размер которых настолько велик, что создавать их в Eden, а потом таскать за собой по Survivor’ам слишком накладно. В этом случае они размещаются сразу в Tenured.). Именно сюда его помещает JVM в момент создания. Но со временем может оказаться так, что места для вновь создаваемого объекта в Eden нет, в таких случаях запускается малая сборка мусора.

Первым делом такая сборка находит и удаляет мертвые объекты из Eden. Оставшиеся живые объекты переносятся в пустой регион Survivor. JVM постоянно следит за тем, как долго объекты перемещаются между Survivor 0 и Survivor 1, и выбирает подходящий порог для количества таких перемещений, после которого объекты перемещаются в Tenured, то есть переходят в старшее поколение. Если регион Survivor оказывается заполненным, то объекты из него также отправляются в Tenured.

![](https://hsto.org/files/20b/a5e/2fa/20ba5e2faa614c558593413268b729c2.png)

Из двух основных способов работы с выжившими объектами — уплотнение и копирование — в Sun при разработке малого сборщика мусора пошли по второму пути, так как он проще в реализации и зачастую оказывается производительнее.старшее поколение не делится на подрегионы по аналогии с младшим, а представляет собой один большой кусок памяти, поэтому после удаления мертвых объектов из Tenured производится не перенос данных (переносить уже некуда), а их уплотнение, то есть размещение последовательно, без фрагментации.

**Parallel (параллельный) GC** — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности(используется чаще всего).

При подключении параллельного сборщика используются те же самые подходы к организации кучи, что и в случае с Serial GC — она делится на такие же регионы Eden, Survivor 0, Survivor 1 и Old Gen (знакомый нам под именем Tenured), функционирующие по тому же принципу. Но есть два принципиальных отличия в работе с этими регионами: во-первых, сборкой мусора занимаются несколько потоков параллельно; во-вторых, данный сборщик может самостоятельно подстраиваться под требуемые параметры производительности.

Определяется общее количество потоков, которое равно количеству ядер, если ядер <= 8(если >, то домнажение на определенный коэффициент).Каждый поток сборщика получает свой участок памяти в регионе Old Gen, так называемый буфер повышения (promotion buffer), куда только он может переносить данные, чтобы не мешать другим потокам. Такой подход ускоряет сборку мусора, но имеет и небольшое негативное последствие в виде возможной фрагментации памяти.

![](https://hsto.org/files/bed/e1a/c4c/bede1ac4c5c84aa9a3363a446b1be0b6.png)

Интеллектуальная составляющая улучшений параллельного сборщика относительно последовательного заключается в том, что у него есть настройки, ориентированные на достижение необходимой вам эффективности сборки мусора. Вы можете указать устраивающие вас параметры производительности — максимальное время сборки и/или пропускную способность — и сборщик будет изо всех сил стараться не превышать заданные пороги. Для этого он будет использовать статистику уже прошедших сборок мусора и исходя из нее планировать параметры дальнейших сборок: варьировать размеры поколений, менять пропорции регионов.

**Concurrent Mark Sweep (CMS)** — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти.

CMS GC использует ту же самую организацию памяти, что и уже рассмотренные Serial / Parallel GC: регионы Eden + Survivor 0 + Survivor 1 + Tenured и такие же принципы малой сборки мусора. Отличия начинаются только тогда, когда дело доходит до полной сборки. В случае CMS ее называют старшей (major) сборкой, а не полной, так как она не затрагивает объекты младшего поколения. В результате, малая и старшая сборки здесь всегда разделены.

Важным отличием сборщика CMS от рассмотренных ранее является также то, что он не дожидается заполнения Tenured для того, чтобы начать старшую сборку. Вместо этого он трудится в фоновом режиме постоянно, пытаясь поддерживать Tenured в компактном состоянии.

Старшая сборка начинается с остановки основных потоков приложения и пометки всех объектов, напрямую доступных из корней. После этого приложение возобновляет свою работу, а сборщик параллельно с ним производит поиск всех живых объектов, доступных по ссылкам из тех самых помеченных корневых объектов. После сборщик еще раз приостанавливает работу приложения и просматривает кучу для поиска живых объектов, ускользнувших от него за время первого прохода. После того, как живые объекты помечены, работа основных потоков приложения возобновляется, а сборщик производит очистку памяти от мертвых объектов в нескольких параллельных потоках. При этом следует иметь в виду, что после очистки не производится упаковка объектов в старшем поколении, так как делать это при работающем приложении весьма затруднительно.

![](https://hsto.org/files/f9f/d54/9a2/f9fd549a2a104f1eb7acf5098dd0afe8.png)

Отдельно следует рассмотреть ситуацию, когда сборщик не успевает очистить Tenured до того момента, как память полностью заканчивается. В этом случае работа приложения останавливается, и вся сборка производится в последовательном режиме.

**Garbage-First (G1)** — создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных

Куча разделяется на набор областей кучи одинакового размера, каждый из которых представляет собой непрерывный диапазон виртуальной памяти. Регионы одного поколения не обязаны идти подряд и даже могут менять свою принадлежность к тому или иному поколению.

![](https://hsto.org/files/34d/781/181/34d781181f5e4481be98557899ae0cf2.png)

Малые сборки выполняются периодически для очистки младшего поколения и переноса объектов в регионы Survivor, либо их повышения до старшего поколения с переносом в Tenured. Над переносом объектов трудятся несколько потоков, и на время этого процесса работа основного приложения останавливается. Это уже знакомый нам подход из рассмотренных ранее сборщиков, но отличие состоит в том, что очистка выполняется не на всем поколении, а только на части регионов, которые сборщик сможет очистить не превышая желаемого времени. При этом он выбирает для очистки те регионы, в которых, по его мнению, скопилось наибольшее количество мусора и очистка которых принесет наибольший результат. Отсюда как раз название Garbage First — мусор в первую очередь.

После окончания малой сборки и пометки мусора, G1 переключается на выполнение смешанных сборок. Это значит, что при каждой сборке к набору регионов младшего поколения,подлежащих очистке, добавляется некоторое количество регионов старшего поколения. Количество таких сборок и количество очищаемых регионов старшего поколения выбирается исходя из имеющейся у сборщика статистики о предыдущих сборках таким образом, чтобы не выходить за требуемое время сборки. Как только сборщик очистил достаточно памяти, он переключается обратно в режим малых сборок.

![](https://hsto.org/files/8ee/d12/62d/8eed1262d47a407a9f64f2df8635bdb6.png)

Может оказаться так, что в процессе очистки памяти в куче не остается свободных регионов, в которые можно было бы копировать выжившие объекты. В таком случае сборщик выполняет полную сборку мусора по всей куче при остановленных основных потоках приложения.

**5. Что произойдет со сборщиком мусора, если во время выполнения метода finalize() некоторого объекта произойдет исключение?**

Ответ: Во время старта JVM запускается поток finalizer, который работает в фоне. Этот поток имеет метод runFinalizer, который игнорирует все исключения методов finalize объектов перед сборкой мусора.

Т.е. во время выполнения метода finalize возникнет исключительная ситуация, его выполнение будет остановлено и это никак не скажется на работоспособности самого сборщика мусора.