**1. Чем отличается JRE, JVM и JDK?**

Ответ: JRE(Java Runtime Environment) - минимальная реализация виртуальной машины, необходимая для исполнения приложений, без компилятора и других средств разработки. Состоит из виртуальной машины и библиотеки java-классов. 

JDK(Java Development Kit) - бесплатно распространяемый компанией Oracle Corporation комплект разработчика приложений на языке Java, включающий в себя компилятор(javac), стандартные библиотеки классов Java, примеры, документацию, различные утилиты и исполнительную систему JRE.

JVM(Java Virtual Machine) - виртуальная машина Java, основная часть исполняющей системы JRE. Виртуальная машина Java интерпретирует байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java(javac). JVM может также использоваться для выполнения программ, написанных на других языках программирования.

**2. Опишите модификаторы доступа в Java.**

Ответ: private - доступ разрешен только в текущем классе; default - доступ на уровне пакета; protected - доступ на уровне пакета и в иерархии наследования; public - доступен всем.

**3. Что такое package level access?**

Ответ: Доступ из классов одного пакета в классы другого пакета.

**4. Чем абстрактный класс отличается от интерфейса? В каких случаях вы бы использовали абстрактный класс, а в каких интерфейс?**

Ответ: Абстрактный класс - это класс, который помечен как "abstract", он может(а может и нет) содержать абстрактные методы. Экземпляр абстрактного класса нельзя создать. Если класс наследуется от абстрактного класса - он тоже дб абстрактным. 

Интерфейс - абстрактный класс, у которого все методы public и abstract, а переменные public static final. Начиная с Java 8  в интерфейсах появились default methods(логика метода реализована по умолчанию). При реализации интерфейсов - класс обязан реализовать все методы интерфейса, иначе класс помечается как абстрактный. Интерфейсы мб использованы для передачи функции в другой метод, такие интерфейсы - функциональные.

Интерфейсы используются для организации множественного наследования. Абстрактый класс используется, когда  нам нужна какая-то реализация по умолчанию, интерфейс - когда классу нужно указать конкретное поведение. Часто абстрактный класс и интерфейс комбинируют, чтобы указать поведение и реализацию по умолчанию.

**5. Может ли объект получить доступ к private-переменной класса? Если да, то каким образом?**

Ответ: Доступ у приватной переменной класса можно получить только внутри класса, в котором она объявлена. Также доступ к переменной можно получить через Java Reflection API(это механизм исследования данных о программе во время её выполнения). Также с помощью него можно определить класс объекта, получить информацию о модификаторах доступа(полях, методах, конструкторах), создать экземпляр класса(имя которого неизвестно до момента выполнения программы), получить и установить значение свойства объекта. Для получения private : gettDeclaredField(), setAccessible(true), setInt(). final-переменные остаются неизменными.

**6. Для чего в Java статические блоки?**

Ответ: Статические блоки выполняются до выполнения конструктора, с помощью них инициализируются статические поля. Блок статической инициализации может создаваться сам при компиляции программы : public static int MAX = 10.

**7. Можно ли перегрузить static-метод?**

Ответ: Статические методы могут перегружаться нестатическими и наоборот - без ограничений. А вот переопределяться - нет.

**8. Расскажите про внутренние классы, когда вы их будете использовать?**

Ответ: Внутренний класс - это класс, который находится внутри класса или интерфейса. ри этом он получает доступ ко всем полям и методам внешнего класса. Статический класс не содержит ссылки на внешний класс и имеет доступ только к статическим методам и переменным. Используется для того, чтобы обеспечить какую-то дополнительную логику класса.

**9. В чем разница между переменной экземпляра и статической переменной?**

Ответ: Статические переменные инициализируются при загрузке класслодером, и не зависят от объекта (глобальная переменная для подсчета пользователей на сайте). Переменная экземпляра инициализируется при создании класса(каждый пользователь на сайте - объект).

**10. Приведите пример кода, когда можно использовать статический метод?**

Ответ: Статические методы мб использованы для инициализации статических переменных. Часто статические методы используются в классах утилитах, таких как Collections, Math, Arrays.

**11. Расскажите про классы-загрузчики и про динамическую загрузку классов?**

Ответ: В Java существует три стандартных загрузчика, каждый из которых осуществляет загрузку класса из определенного места: Bootstrap – базовый загрузчик, также называется Primordial ClassLoader(загружает стандартные классы JDK из архива rt.jar); Extension ClassLoader – загрузчик расширений(загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext, но могут быть заданы системным свойством java.ext.dir);System ClassLoader – системный загрузчик (загружает классы приложения, определенные в переменной среды окружения CLASSPATH).

В Java используется иерархия загрузчиков классов, где корневым, разумеется, является базовый. Далее следует загрузчик расширений, а за ним уже системный. Естественно, каждый загрузчик хранит указатель на родительский для того, чтобы смочь делегировать ему загрузку в том случае, если сам будет не в состоянии этого сделать.

**12. Для чего нужен оператор assert в Java?**

Ответ: Утверждения (с помощью ключевого слова assert) были добавлены в Java 1.4. Они используются для проверки правильности инварианта в коде. Они никогда не должны запускаться в производственном коде и указывают на ошибку или неправильное использование кода. Исключения Java - это аналогичная концепция, но они не могут проверить все. Если вы хотите еще больше проверок (за счет скорости выполнения), вам нужно использовать утверждения. Это приведет к раздуванию вашего кода, но в конечном итоге вы сможете доставить продукт на удивительно короткое время разработки (чем раньше вы исправляете ошибку, тем ниже стоимость). И кроме того: если в вашем коде есть какая-то ошибка, вы ее обнаружите.
```java
void doSomething(Widget widget) {
  assert widget != null;
  widget.someMethod(); // ...
    ... // do more stuff with this widget
}
```

**13. Почему в некоторых интерфейсах вообще не определяют методов?**

Ответ: Это интерфейсы маркеры. Они просто указывают, что класс относится к определенной группе классов. Интерфейсы-маркеры : Searilizable, Cloneable, Remote, ThreadSafe.

**14. Расскажите про потоки ввода/вывода в Java?**

Ответ: Потоком ввода/вывода (I/O Stream) называется произвольный источник или приемник, который способен генерировать либо получать некоторые данные. Данными выступают последовательности байт. Таким образом поток ввода/вывода – это последовательность байт. С точки зрения потоков ввода/вывода Java программа сможет работать с последовательностью байт с файла, сетевого соединения интернет сайта и т.д. без каких либо изменений в коде.

Для работы с двоичными (бинарными) данными в Java существуют два базовых абстрактных класса: InputStream и OutputStream; для работы с текстовыми данными в Java существуют два базовых абстрактных класса: Reader и Writer. 

При работе с потоками ввода/вывода обязательно использовать try-with resource конструкцию, иначе может быть утечка памяти и сбой в работе программы. 

java.io.File класс представляет АПИ для доступа к объекту файловой системы. Начиная с версии JDK 1.7 в Java   Path и Files для работы с объектами файловой системы. Properties файлы удобны для настроек системы.

**15.  Расскажите про приведение типов. Что такое понижение и повышение типа? Когда вы получаете ClassCastException?**

Ответ: Приведение типов - это установка типа переменной или объекта отличного от текущего.

![](https://vertex-academy.com/tutorials/wp-content/uploads/2016/11/%D0%9F%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-Java_Vertex-Academy.png)

Автоматическое преобразование выглядит следующим образом:

![](https://vertex-academy.com/tutorials/wp-content/uploads/2016/09/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-Java_Vertex-Academy.png)

Если мы расширяем тип, то явное преобразование не требуется, приведение происходит автоматически. Если же мы сужаем, то необходимо явно указывать приведение типа.

В случае с объектами, то мы можем сделать автоматическое приведение от наследника к родителю, но никак наоборот, тогда вылетит ClassCastException.

**16. Что такое статический класс? Какие особенности его использования?**

Ответ: Статический класс м.б. только внутренний класс(определение класса размещается внутри другого класса). В объекте обычного внутреннего класса хранится ссылка на объект внешнего класса. Внутри статического внутреннего класса такой ссылки нет. Из объекта статического вложенного класса нельзя обращаться к нестатическим членам внешнего класса напрямую.

И еще обычные внутренние классы не могут содержать статические методы и члены. Каждый внутренний класс способен независимо наследовать определенную реализацию. Т.об. внутренний класс не ограничен при наследовании в ситуациях, когда внешний класс уже наследует реализацию(т.е. вариант решения проблемы множественного наследования).

**17. Каким образом из вложенного класса получить доступ к полю внешнего класса?**

Ответ: *ВнешнийКласс.this.поле, для статического внутреннего класса - создать объект внешнего класса, и вызвать get/set внешнего класса. Или объявить поле внешнего класса как static*

**18. Какие существуют типы вложенных классов? Для чего они используются?**

Ответ: Два типа вложенных классов: статические(вложенный) и нестатические(внутренние, анонимные).

Вложенный класс имеет доступ к членам своего внешнего класса, в том числе и к закрытым членам. Однако, внешний класс не имеет доступа к членам вложенного класса. Вложенный класс при этом является членом внешнего класса.

Внутренний класс имеет доступ ко всем переменным и методам своего внешнего класса и может непосредственно ссылаться на них.Если понадобится создать объект внутреннего класса не в статическом методе внешнего класса, тип этого объекта должен задаваться в формате ИмяВнешнегоКласса.ИмяВнутреннегоКласса.

Существует разновидность внутреннего класса, которая называется анонимным классом, так как у него нет имени. Подобные классы очень часто встречаются в примерах на Android.

**19. Возможно ли при переопределении метода изменить: 1 модификатор доступа, 2 возращаемый тип, 3 тип аргумента или количество, 4 имя аргументов, 5 изменить порядок, количество или вовсе убрать секцию throws?**

Ответ: 1 - возможно изменить модификатор доступа, только при переопределении модификатора разрешается только расширить видимость метода(package -> protected -> public).

2 - возможно изменить возращаемый тип, только если выполняется понижающее преобразование(Downcasting), т.е. преобразование вниз по иерархии(Object -> Number -> Integer).

3 - нельзя изменить тип аргумента или количество, т.к. в таком случае происходит перегрузка(overload).

4 - можно изменять имя аргументов.

5 - возможно изменить порядок. Можно вовсе убрать секцию throws в методе, так как она уже определена. Также возможно добавлять новые исключения, которые наследуются от объявленных или исключения времени исполнения.

**20. Что такое Autoboxing/Unboxing?**

Ответ: Autoboxing/Unboxing - автоматическое преобразование примитивных типов в объектные и наоборот. Наличие такой возможности сокращает код, поскольку исключает необходимость выполнения явных преобразований  типов в очевидных случаях.

* Расширение "побеждает" упаковку в ситуации, когда становится выбор между расширением и упаковкой, расширение предпочтительней.
* Расширение побеждает переменное количество аргументов в ситуации, когда становится выбор между расширением и переменным количеством аргументов, расширение предпочтительней.
* Упаковка побеждает переменное количество аргументов в ситуации, когда становится выбор между упаковкой и переменным количеством аргументов, упаковка предпочтительней.
* Смешивание объектов и примитивных типов с оператором равенства и отношения. Если мы сравниваем примитивный тип с объектом, то происходит распаковывание объекта, который может бросить NullPointerException если объект null.
* Кэширование объектов. Метод valueOf() создает контейнер примитивных объектов, которые он кэширует. Поскольку значения кэшируются в диапазоне от -128 до 127 включительно , эти кэшируемые объекты могут себя вести по-разному.
* Ухудшение производительности. Автоупаковка или распаковка ухудшают производительность приложения, поскольку это создает нежелательный объект, из-за которого сборщику мусора приходится работать чаще.

**21. Что такое Generics?**

Ответ: Generics(обобщения) - это параметризованные типы.С их помощью можно объявлять классы, интерфейсы и методы, где тип данных указан в виде параметра. Одно из назначений — более сильная проверка типов во время компиляции и устранение необходимости явного приведения. Параметризация доступна только на уровне компиляции.

**22. Какова истинная цель использования  обобщенных типов в Java?**

Ответ: Обобщенные типы в Java были изобретены, в первую очередь, для реализации обощенных коллекций.

**23. Каким образом передаются переменные в методы, по значению или по ссылке?**
Ответ: В Java параметры в методы передаются по значению, т.е. создаются копии параметров и с ними ведется работа в методе. В случае с примитивными типами, то при передаче  параметра сама переменная  не будет меняться, т.к. в метод прсто копируется ее значение.

При передаче объекта, копируется ссылка на объект, т.е. если в методе  мы поменяем состояние объекта, то и за методом состояние объекта тоже поменяется. Но если мы этой копиии ссылки попытаемся присвоить новую ссылку на объект, то старая ссылка  у нас не изменится.

Т.об объекты передаются по ссылке, а примитивы - по значению.


**24. Что такое конструктор по умолчанию?**

Ответ: В Java, если нет явным образом определенных конструкторов в классе, то компилятор использует  конструктор по умолчанию, определенный неявным образом. Конструктор по умолчанию - простая конструкция, которая сводится  к созданию для типа конструктора без параметров.

Если производный класс не вызывает явным образом конструктор базового класса(super() в первой строчке), то конструктор по умолчанию вызывается неявно. Если базовый класс не имеет конструктора по умолчанию, то это считается ошибкой.

**25. Где и как вы можете использовать закрытый конструктор?**

Ответ: Например, в качестве паттерна проектирования Singleton. Сделать конструктор класса (конструктор по-умолчанию) приватным (чтобы доступ к нему был закрыть за пределами класса, тогда он не сможет возвращать новые объекты)

``` java
public class LazyInitializedSingleton {
    private static LazyInitializedSingleton instance;
        private LazyInitializedSingleton(){}
        public static LazyInitializedSingleton getInstance(){ // #3
        if(instance == null){		//если объект еще не создан
            instance = new LazyInitializedSingleton();	//создать новый объект
        }
        return instance;		// вернуть ранее созданный объект
    }
}
```

 **26. Что такое рефлексия?**

 Ответ: Рефлексия - для получения или модификации информации о типах во время выполнения программы. Этот механизм помогает получить сведения о классах, интерфейсах, полях, методах, конструкторах во время выполнения программы. Также этот механизм позволяет создавать новые объекты, выполнять методы, получать и устанавливать значения полей.

**27. Что такое интернационализация и локализация?**

Ответ: Интернационализация(il8n) - способ создания приложений, при котором их можно легко адаптировать для разных аудиторий, говорящих на разных языках.

Локализация(il0n) - адаптация интерфейса приложения  под несколько языков.


















