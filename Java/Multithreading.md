**1. ЧЕМ ОТЛИЧАЕТСЯ ПРОЦЕСС ОТ ПОТОКА?**

Ответ: Процесс - это некоторая единица ОС, которой выделена память и другие ресурсы. Поток - это единица исполнения кода. Поток имеет стэк - некоторую свою память для исполнения. Остальная память процессора - общая для всех его потоков. Потоки исполняются на ядрах процессора. В некоторых ОС разница между процессами и потоками сведена к минимуму.

**2. КАКИМ ОБРАЗОМ МОЖНО СОЗДАТЬ ПОТОК?**

Ответ: Есть несколько способов создания и запуска потоков.

1. С помощью класса, реализующего Runnable
 * Создать объект класса Thread;
 * Создать объект класса, реализующего интерфейс Runnable;
 * Вызвать у созданного объекта Thread метод start()(после этого запустится метод run() у переданного объекта, реализующего Runnable);
2. С помощью класса расширяющего Thread
* Создать объект класса ClassName extends Thread;
* Переопределить run() в этом классе;
3. С помощью класса, реализующего java.util.concurrent.Callable
* Создать объект класса, реализующий  интерфейс Callable;
* Создать объект ExecutorService с указанием пула потоков;
* Создать объект Future. Запуск происходит через метод submit(). Сигнатура <T> Future<T> submit(Callable<T> task)

**3. ЧТО ТАКОЕ МОНИТОР?**

Ответ: Контроль за доступом к объекту-ресурсу обеспечивает понятие монитор. Монитор экземпляра может иметь только одного владельца. При попытке конкурирующего доступа к объекту, чей монитор имеет владельца, желающий заблокировать объект - ресурс поток должен подождать освобождение монитора этого объекта и только после этого завладеть им и начать использование объекта-ресурса.

**4. КАКИЕ СПОСОБЫ СИНХРОНИЗАЦИИ В JAVA?**

Ответ: 

* Системная синхронизация с использованием wait/notify. Поток, который ждет выполнения какихх-либо условий, вызывает у этого объекта метод wait, предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify(опять же предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток "просыпается" и продолжает свое выполнение;
* Системная синхронизация с использованием join. Метод join, вызванный у экземпляра класса Thread, позволяет текущему потоку остановится до того момента, как поток, связанный с этим экземпляром, закончит работу;
* Использование классов из пакета java.util.concurrent, который предоставляет набор классов для организации межпоточного взаимодействия. Примеры таких классов - Lock, Semaphore ... Концепция данного подхода заключается с использовании атомарных операций и переменных.

**5. КАК РАБОТАЮТ МЕТОДЫ WAIT/NOTIFY/NOTIFYALL?**

Ответ: Эти методы предназначены для межпоточной синхронизации, для взаимодействия потоков между собой.

Во-первых, методы м.б. вызваны только потоком, который захватил монитор объекта, для которого эти методы вызываются. Т.е. они вызываются внутри блока synchronized и для объекта, монитор которого этим synchronized захвачен. Если внутри synchronized метода - то для класса, к которому относятся эти методы.

Метод wait() отдает(освобождает) монитор объекта, так что другие потоки теперь могут захватить монитор, т.е. войти в блок synchronized для этого объекта. Затем метод wait() переходит в состояние ожидания, до тех пор  пока другой поток не вызовет метод notify/notifyAll для того же объекта. После чего поток, в котором быз вызван метод wait(), пытается снова захватить монитор, и когда монитор становится свободным - захватывает.

Методы  notify/notifyAll пробуждают поток, ожидающий методом wait() и переводят его в состояние ожидания освобождения монитора. Метод notify() - пробуждает один поток, какой именно будет освобожден определить нельзя, а метод notifyAll() - пробуждает все потоки.

**6. ЧЕМ ОТЛИЧАЕТСЯ РАБОТА МЕТОДА WAIT С ПАРАМЕТРОМ И БЕЗ ПАРАМЕТРА?**

Ответ: 

* final void wait() - метод используется в многопоточной среде, может вызываться только потоком, владеющим объектов синхронизации. При этом объект синхронизации освобождается,а текущий поток переходит в состояние ожидания сигнала освобождения объекта синхронизации другим потоком путем вызова метода notify() либо notifyAll();
* final void wait(long time) - аналогично wait(), но ожидание происходит заданное время time.

**7. ЧЕМ ОТЛИЧАЮТСЯ МЕТОДЫ THREAD.SLEEP() И THREAD.YIELD()?**

Ответ: 

* Метод yield() - пытается сказать планировщику потоков, что нужно выполнить другой поток, что ожидает в очереди на выполнение. Метод не пытается перевести текущий поток в состояние блокировки, сна или ожидания. Он просто пытается его перевести из состояния "работающий" в состояние "работоспособный". Однако выполнение метода может вообще не произвести никакого эффекта. Состояние потока - Runnable.

Метод yield лишь передаёт некоторую рекомендацию планировщику потоков Java, что данному потоку можно дать меньше времени исполнения. Но что будет на самом деле, услышит ли планировщик рекомендацию и что вообще он будет делать — зависит от реализации JVM и операционной системы. 

* Метод sleep() - приостанавливает поток на указанное время, состояние меняется на Timed_Waiting.

**8. КАК РАБОТАЕТ МЕТОД THREAD.JOIN()?**

Ответ: Метод join() вызывается для того, чтобы привязать текущий поток в конец потока, для которого вызывается метод. Т.е. второй поток будет в режиме блокировки, пока первый поток не выполнится.

**9. ЧТО ТАКОЕ DEADLOCK?**

Ответ: Deadlock – тупик, ошибка при выполнении программы, которая состоит в том, что каждый из двух элементов процесса ожидает ответа или действия от другого элемента, следовательно программа не в состоянии продолжить работы.

**10. НА КАКОМ ОБЪЕКТЕ ПРОИСХОДИТ СИНХРОНИЗАЦИЯ ПРИ ВЫЗОВЕ STATIC SYNCHRONIZED МЕТОДА?**

Ответ: Статические методы блокируются  на экземпляре класса  Class, в то время как  нестатические методы блокируются на текущем экземпляре (this).

**11. ДЛЯ ЧЕГГО ИСПОЛЬЗУЮТСЯ КЛЮЧЕВЫЕ СЛОВА VOLATILE, SYNCHRONIZED, TRANSIENT, NATIVE?**

Ответ: 

* volatile - указывает на то, что поле синхронизированно для нескольких потоков;
* synchronized - указывает на то, что метод синхронизированный или же в методе может находится такой блок синхронизации;
* transient - указывает на то, что переменная не подлежит сериализации;
* native - говорит о том, что реализация метода написана на другой программной платформе.

**12. ЧТО ЗНАЧИТ ПРИОРИТЕТ ПОТОКА?**

Ответ: Число от 1 до 10, в зависимости от которого, планировщик потоков выбирает какой поток запускать.

**13. ЧТО ТАКОЕ ПОТОКИ-ДЕМОНЫ В JAVA?**

Ответ: Это потоки которые работают в фоновом режиме и не гарантируют, что они завершаться. Т.е. если все потоки завершились, то поток демон просто   обрывается вместе с закрытием приложения.

**14. ЧТО ЗНАЧИТ УСЫПИТЬ ПОТОК?**

Ответ: Перевести поток в спящее состояние можно с помощью метода sleep(). При вызове этого метода, поток переходит в спящее состояние, после сна, поток переходит в пул потоков и находится в состоянии "работоспособный", т.е. не гарантируется, что после пробуждения он будет сразу выполняться.

**15. В КАКИХ СОСТОЯНИЯХ МОЖЕТ БЫТЬ ПОТОК В JAVA? КАК ВООБЩЕ РАБОТАЕТ ПОТОК?**

Ответ: Есть текущий поток, в котором выполняется метод main. Этот поток имеет свой стек и этот стек начинается с вызова метода main. Далее в методе main, мы создаем новый поток, что происходит..создается новый поток и для него выделяется свой стек с первоначальным методом run(). Когда мы запускаем несколько потоков, то мы не можем гарантировать определенный порядок их вызовов. Планированием потоков занимается планировщик потоков JVM, выбирая из пулов потоков поток. Мы даже не можем гарантировать, что если первый поток начался выполняться первым, то он и закончит выполняться первым, он может закончить выполняться последним. Поток, который закончил свое выполнение, не может быть повторно запущен, т.к. он находится в состоянии "мертвый".

Состояния бывают: 

* новый - это когда только создали экземпляр класса Thread;
* живой/работоспособный - переходит в это состояние после запуска метода start();
* работающий - это когда метод run() начал выполняться;
* ожидающий/заблокированный/спящий - потоки, который не готовы к работе, но он можт вернуться в рабочее состояние;
* мертвый - состояние, когда метод run() завершил свою работу.  

**16. ЧЕМ ОТЛИЧАЮТСЯ ДВА ИНТЕРФЕЙСА ДЛЯ РЕАЛИЗАЦИИ ЗАДАЧ RUNNABLE И CALLABLE?**

Ответ: 

* Интерфейс Runnable появился в Java 1.0, интерфейс Callable был введен в составе библиотеки java.util.concurrent;
* Классы, реализующие интерфейс Runnable, должны реализовать метод run() для выполнения задачи, а Callable -  метод call();
* Метод run() не возвращает никакого значения, его тип void, а метод call() может возвращать занчение типа Т(интерфейс Callable является параметризированным);
* Метод run() не может бросить проверяемое исключение, в то время как метод call() может бросить проверяемое исключение.

**17. РАЗЛИЧИЯ МЕЖДУ CYCLICBARRIER И COUNTDOWNLATCH?**

Ответ: Хоть оба эти синхронизатора позволяют нитям дожидаться друг друга, главное различие между ними в том, что вы не можете использовать CountDownLatch после того, как его счетчик достигнет нуля, но вы можете использовать CyclicBarrier снова, даже после того, как барьер сломается.

**18. ЧТО ТАКОЕ СОСТОЯНИЕ ГОНКИ(RACE CONDITION)?**

Ответ: Состояние гонки возникает из-за гонки между несколькими нитями, если нить, которая должна исполняться первой проиграла гонку и исполняется вторая, поведение кода изменяется, из-за чего возникают недетерменированные баги. 

**19. КАК ОСТАНОВИТЬ НИТЬ?**

Ответ: В JDK 1.0  было несколько управляющих методов, которые были помечены как depricated в будущих релизах из-за потенциальных угроз взаимной блакировки. Для остановки вручную, программисты пользуются преимуществом volatile boolean переменной и проверяют ее значение в каждой итерации, если в методе run() есть циклы. Прерывают нити методом interrupt() для внезапной отмены заданий.

**20. ЧТО ПРОИСХОДИТ, КОГДА В НИТИ ПОЯВЛЯЕТСЯ ИСКЛЮЧЕНИЕ?**

Ответ: Если исключение не поймано - нить мертва, а если установлен обработчик непойманных исключений, он получит callback. Thread.UncaughtExceptionHandler - интерфейс, определенный как вложенный интерфейс для обработчиков, вызываемых, когда нить внезапно останавливается из-за непойманного исключения. Когда нить собирается остановится из-за непойманного исключения, JVM проверит её  на наличие UncaughtExceptionHandler, используя Thread.getUncaughtExceptionHandler, и вызовет  у обработчика метод uncaughtException(), передав нить и исключение в виде аргументов.

**21. ЧТО ТАКОЕ THREADLOCAL ПЕРЕМЕННАЯ?**

Ответ: Это неплохой способ достичь нитебезопасности для затратных для создания объектов. Например, вы можете сделать SimpleDateFormat нитебезопасным, используя ThreadLocal. Т.к. это затратный класс, его нежелательно использовать в локальной области, которая требует отдельных экземпляров на каждый вызов. Предоставляя каждой нити её собственную копию, во-первых - вы уменьшаете количество экземпляров затратных объектов, используя по новой фиксированное количество экземпляров, а во-вторых - вы достигаете нитебезопасности, без потерь синхронизации и неизменяемости.

**22. ЧТО ТАКОЕ FUTURETASK?**

Ответ: FutureTask представляет собой отменяемое асинхронное вычисление в параллельном приложении. Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. Результат м.б получен только тогда, когда вычисление завершено, метод получения будет заблокирован, если вычисление еще не завершено. Объекты FutureTask м.б. использованы для обертки объектов Callable и Runnable.

**23. РАЗЛИЧИЯ МЖДУ INTERRUPTED И ISINTERRUPTED?**

Ответ: interrupted() - сбрасывает статус  прерывания, а isInterrupted() - нет. Механизм прерывания в Java реализован с использованием внутреннего флага, известного как статус прерывания. Прерывание нити вызовом Thread.interrupt() устанавливает этот флаг, вызов метода Thread.interrupted() - сбрасывает статус прерывания, а нестатический метод isInterrupted() - не изменяет флаг прерывания, использзуется нитью для проверки статуса прерывания у другой нити.

**24. ЧТО ТАКОЕ ПУЛ НИТЕЙ?**

Ответ: Создание нити затратно в плане времени и ресурсов. Если вы создаете нить во время обработки запроса, это замедлик время отклика, также процесс может создать только ограниченное число нитей. Чтобы избежать этих проблем, во время запуска приложения создается пул нитей и нити повторно используются для обработки запросов. Начиная с Java 1.5 Java API предоставляет фреймворк  Executor, который позволяет вам создавать различные пулы нитей(single thread pool - обрабатывает только одно задание за единицу времени; fixed thread pool - фиксированное количество нитей в пуле; cached thread pool - расширяемый пул, которй подходит с множеством недолгих заданий).

**25. КАК ПРОВЕРИТЬ УДЕРЖИВАЕТ ЛИ НИТЬ LOCK?**

Ответ: В Java.lang.Thread есть метод holdsLock(), он возвращает true, тогда и только тогда, когда текущая нить удерживает монитор у определенного объекта.

**26. ЧТО ТАКОЕ ДАМП НИТИТ?**

Ответ: Дамп нити позволяет узнать, чем нить занимается в данный момент.

**27. КАКОЙ JVM ПАРАМЕТР ИСПОЛЬЗУЕТСЯ ДЛЯ КОНТРОЛЯ РАЗМЕРА СТЕКА НИТИ?**

Ответ: -Xss

**28. РАЗЛИЧИЯ МЕЖДУ SYNCHRONIZED И REENTRANTLOCK?**

Ответ: В synchronized нельзя расширрить lock за пределами метода или блока кода. Lock.ReentrantLock - решает эту проблему.

**29. ЧТО ТАКОЕ СЕМАФОР?**

Ответ: Семафор -  при создании механизма синхронизации он использует счетчик. Счетчик указывает нам, сколько потоков одновременно могут получать доступ к общему ресурсу.

**30. РАЗЛИЧИЯ МЕЖДУ МЕТОДАМИ SUBMIT() И EXECUTE() У ПУЛА НИТЕЙ?**

Ответ: Оба метода являются способами подачи задачи в пул нитей. Execute(Runnable command) определен в интерфейсе Executor и выполняет поданную задачу в будущем, но ничегоне возвращает. submit() - перегруженный метод, он может принимать задачи типов Runnable и Callable и может возвращать объект Future, который можно использовать для отмены выполнения и/или ожидания результата вычислений.

**31. ЧТО ТАКОЕ READWRITELOCK?**

**32. ЧТО ТАКОЕ DOUBLE CHECKED LOCKING СИНГЛТОНА?**

**33. ЧТО ТАКОЕ ФРЕЙМОРК FORK/JOIN?**

**34. ПРОБЛЕМЫ МНОГОПОТОЧНОСТИ?**

Ответ: 

* deadlock - когда два и более потоков вечно ожидают друг друга, при этом блокируют свои ресурсы;
* starvation - потоки не заблокированы, а им просто не хватает ресурсов на всех. Поэтому пока одни потоки на себя берут всё время выполнения, другие не могут выполниться;
* race conditions - это явление заключается в том, что потоки делят между собой некоторый ресурс и код написан таким образом, что не предусматривает корректную работу в таком случае;
* livelock -  заключается в том, что потоки внешне как бы живут, но при этом не могут ничего сделать, т.к. условие, по которым они пытаются продолжить свою работу, не могут выполниться. По сути Livelock похож на deadlock, но только потоки не "зависают" на системном ожидании монитора, а что-то вечно делают.