**1. КАКИЕ НОВОВВЕДЕНИЯ ПОЯВИЛИСЬ В JAVA 8?**

Ответ: 

* Полноценная поддержка лямбда-выражений, которая добавляет функциональные возможности обработки данных для Java;
* Ключевое слово default в интерфейсах для поддержки функциональности по умолчанию(интерфейс может иметь реализацию метода по умолчанию);
* Ссылки на методы;
* Функциональные интерфейсы;
* Потоки(stream) для работы с коллекциями;
* Новое API для работы с датами;
* Nashorn движок JavaScript, разрабатываемый полностью на Java компанией Oracle.

**2. КАКОВА СТРУКТУРА ЛЯМБДА-ВЫРАЖЕНИЯ?**

Ответ: (method params) -> {lambda expression body}, где

* method params - список входящих параметров, разделенных запятой(в случае, если параметрв больше одного, заключаются в скобки);
* оператор -> служит разделителем  между списком параметров нашего метода и телом, в котором проходит его реализация;
* lambda expression body - тело метода, состоящее из одного выражения или нескольких, заключенных в фигурные скобки.

**3. КАК СОРТИРОВАТЬ СПИСОК СТРОК С ПОМОЩЬЮ ЛЯМБДА-ВЫРАЖЕНИЯ?**

Ответ: 

![](https://4.bp.blogspot.com/-MzPf6tqX6Ls/VziRrSFYUBI/AAAAAAAAAqo/iOzDNCaSYI8gfFZhLTYM0S3fSx0WLrweQCLcB/s1600/q002_p01.jpg)

**4. К КАКИМ ПЕРЕМЕННЫМ ЕСТЬ ДОСТУП У ЛЯМБДА-ВЫРАЖЕНИЙ?**

Ответ: Лямбда-выражения имеют доступ к переменным области видимости, в которой их определили. Но доступ возможен только при условии, что переменные являются effective final, т.е. либо явно имеют модификатор final, либо не меняют своего значения после инициализации. Если переменной присваивается значение во второй раз, лямбда-выражение вызывает ошибку компиляции.

**5. ЧТО ТАКОЕ ССЫЛКИ НА МЕТОД?**

Ответ: Ссылки на метод - компактные лямбда-выражения, которые позволяют передавать ссылки на метода или конструкторы. Для этого нужно использовать ключевое слово "::".

Ссылочные методы внедряют полезный синтаксис, чтобы ссылаться на существующие методы или конструкторы Java-классов или объектов. Совместно с лямбда-выражениями, ссылочные метода делают языковые конструкции компактными и лаконичными, делая его шаблонным.

**6. КАКИЕ ВИДЫ ССЫЛОК НА МЕТОДЫ ВЫ ЗНАЕТЕ?**

Ответ: 

* Ссылка на статический метод(ContainignClass::staticMethodClass);
* Ссылка на метод конкретного объекта(ContainingObject::instanceMethodName);
* Ссылка на метод произвольного объекта конкретного типа(ContainingType::methodName);
* Ссылка на конструктор(ClassName::new), для дженериков Class<T>::new.

**7. ОБЪЯСНИТЕ ВЫРАЖЕНИЕ SYSTEM.OUT::PRINTLN?**

Ответ: Выражение System.out::println является ссылкой на статический метод println объекта out класса System, который эквивалентен лямбда-выражению x -> System.out.println(x).

**8. ЧТО ТАКОЕ ФУНКЦИОНАЛЬНЫЕ ИНТЕРФЕЙСЫ?**

Ответ: Функциональный интерфейс - это тот интерфейс, который определяет строго один абстрактный метод. В Java 8 была введена новая аннотация @FunctionalInterface для обозначения интерфейса функциональным, эта аннотация используется для того, чтобы избежать случайного добавления абстрактных методов в функциональный интерфейс. Функциональные интерфейсы позволяют использовать лямбда-выражения для создания экземпляра таких интерфейсов.

Пример функционального интерфейса будет интерфейс java.lang.Runnable с одним абстрактным методом run(). Заметим, интерфейс может включать сколько угодно default методов и при этом оставаться функциональным, потому что default-методы - не абстрактные.

**9. ОБЪЯСНИТЕ ДЛЯ ЧЕГО НУЖНЫ СЛЕДУЮЩИЕ ИНТЕРФЕЙСЫ.**

Ответ: 

* BiConsumer<T,U> - представляет собой операцию, которая принимает 2 входных параметра, и не возвращает никакого результата;
* BiFunction<T,U,R> - представляет собой функцию, которая принимает 2 аргумента и возращает результат;
* BinaryOperator<T> - представляет собой операцию над двумя операндами одного и того же типа, выполняет над ними бинарную операцию и возвращает результат тогоже типа, что и операнды;
* BiPredicate<T,U> - представляет собой результат(булеву функцию) 2 аргументов;
* BooleanSupplier|DoubleSupplier - представляет собой поставщика булевых|double результатов;
* Consumer<T> - представляет собой операцию, которая принимает один входной аргумент, выполняет некоторое действие над объектом типа Т, при этом ничего не возвращая;
* DoubleBinaryOperator - представляет собой операцию над 2 операндами типа double, возвращает результат типа double;
* DoubleConsumer - представляет собой операцию, которая принимает один аргумент типа double, и не возвращает результат;
* DoubleFunction<R> - представляет собой функцию, которая принимает один аргумент типа double, и возвращает результат;
* DoublePredicate - представляет собой предикат(булеву функцию) одного аргумента типа double;
* DoubleToIntFunction - представляет собой функцию, которая принимает один аргумент типа double, возвращает результат типа int;
* DoubleToLongFunction - представляет собой функцию, которая принимает один аргумент типа double, возвращает результат типа long;
* DoubleUnaryOperator - представляет собой операцию над одним аргументом типа double, возвращает результат типа double;
* Function<T,R> - представляет собой функцию перехода от объекта типа Т к объекту типа R;
* IntBinaryOperator - представляет собой операцию над 2 операндами типа int, возвращает результат типа int;
* IntConsumer - представляет собой операцию, которая принимает один аргумент типа int, и не возвращает результат;
* IntFunction<R> - представляет собой операцию, которая принимает один аргумент типа int, возвращает результат;
* IntPredicate - представляет собой предикат(булеву функцию) одного аргумента типа int;
* IntSupplier - представляет собой поставщика int результатов;
* IntToDoubleFunction - представляет собой функцию, которая принимает один аргумент типа int, возвращает результат типа double;
* IntToLongFunction - представляет собой функцию, которая принимает один аргумент типа int, возвращает результат типа long;
* IntUnaryOperator - представляет собой операцию над одним аргументом типа int, возвращает результат типа int;
* LongBinaryOperator - представляет собой операцию над 2 операндами типа long, возвращает результат типа long;
* LongConsumer - представляет собой операцию, которая принимает один аргумент типа long, не возвращает результат;
* LongFunction<R> - представляет собой функцию, которая принимает один аргумент  типа long, и возвращает результат;
* LongPredicate - представляет собой предикат(булеву функцию) одного аргумента типа long;
* LongSupplier - представляет собой поставщика long результатов;
* LongToDoubleFunction - представляет собой функцию, которая принимает один аргумент типа long, и возвращает результат типа double;
* LongToIntFunction -  представляет собой функцию, которая принимает один аргумент типа long, и возвращает результат типа int;
* LongUnaryOperator -  представляет собой операцию над oдним аргументом типа long, возвращает результат типа long;
* ObjDoubleConsumer<T> - представляет собой операцию, которая принимает  один аргумент типа Object, и второй типа double, и не возвращает результат;
*  ObjIntConsumer<T> - представляет собой операцию, которая принимает  один аргумент типа Object, и второй типа int, и не возвращает результат;
*  ObjLongConsumer<T> - представляет собой операцию, которая принимает  один аргумент типа Object, и второй типа long, и не возвращает результат;
* Predicate<T> - представляет собой предикат(булеву функцию) одного аргумента;
* Supplier<T> - представляет собой поставщика результатов;
* ToDoubleBiFunction<T,U> - представляет собой функцию, которая принимает 2 аргумента, возвращает результат типа double;
* ToDoubleFunction<T> - представляет собой функцию, которая принимает один аргумент, возвращает результат типа double;
* ToDoubleBiFunction<T,U> - представляет собой функцию, которая принимает 2 аргумента, возвращает результат типа int;
* ToIntFunction<T> - представляет собой функцию, которая принимает один аргумент, возвращает результат типа int;
* ToLongBiFunction<T,U> - представляет собой функцию, которая принимает 2 аргумента, возвращает результат типа long;
* ToLongFunction<T> - представляет собой функцию, которая принимает один аргумент, возвращает результат типа long;
* UnaryOperator<T> - представляет собой операцию над одним операндом, возвращает результат того же типа, что и операнд.



