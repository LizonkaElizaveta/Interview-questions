**1. КАКИЕ НОВОВВЕДЕНИЯ ПОЯВИЛИСЬ В JAVA 8?**

Ответ: 

* Полноценная поддержка лямбда-выражений, которая добавляет функциональные возможности обработки данных для Java;
* Ключевое слово default в интерфейсах для поддержки функциональности по умолчанию(интерфейс может иметь реализацию метода по умолчанию);
* Ссылки на методы;
* Функциональные интерфейсы;
* Потоки(stream) для работы с коллекциями;
* Новое API для работы с датами;
* Nashorn движок JavaScript, разрабатываемый полностью на Java компанией Oracle.

**2. КАКОВА СТРУКТУРА ЛЯМБДА-ВЫРАЖЕНИЯ?**

Ответ: (method params) -> {lambda expression body}, где

* method params - список входящих параметров, разделенных запятой(в случае, если параметрв больше одного, заключаются в скобки);
* оператор -> служит разделителем  между списком параметров нашего метода и телом, в котором проходит его реализация;
* lambda expression body - тело метода, состоящее из одного выражения или нескольких, заключенных в фигурные скобки.

**3. КАК СОРТИРОВАТЬ СПИСОК СТРОК С ПОМОЩЬЮ ЛЯМБДА-ВЫРАЖЕНИЯ?**

Ответ: 

![](https://4.bp.blogspot.com/-MzPf6tqX6Ls/VziRrSFYUBI/AAAAAAAAAqo/iOzDNCaSYI8gfFZhLTYM0S3fSx0WLrweQCLcB/s1600/q002_p01.jpg)

**4. К КАКИМ ПЕРЕМЕННЫМ ЕСТЬ ДОСТУП У ЛЯМБДА-ВЫРАЖЕНИЙ?**

Ответ: Лямбда-выражения имеют доступ к переменным области видимости, в которой их определили. Но доступ возможен только при условии, что переменные являются effective final, т.е. либо явно имеют модификатор final, либо не меняют своего значения после инициализации. Если переменной присваивается значение во второй раз, лямбда-выражение вызывает ошибку компиляции.

**5. ЧТО ТАКОЕ ССЫЛКИ НА МЕТОД?**

Ответ: Ссылки на метод - компактные лямбда-выражения, которые позволяют передавать ссылки на метода или конструкторы. Для этого нужно использовать ключевое слово "::".

Ссылочные методы внедряют полезный синтаксис, чтобы ссылаться на существующие методы или конструкторы Java-классов или объектов. Совместно с лямбда-выражениями, ссылочные метода делают языковые конструкции компактными и лаконичными, делая его шаблонным.

**6. КАКИЕ ВИДЫ ССЫЛОК НА МЕТОДЫ ВЫ ЗНАЕТЕ?**

Ответ: 

* Ссылка на статический метод(ContainignClass::staticMethodClass);
* Ссылка на метод конкретного объекта(ContainingObject::instanceMethodName);
* Ссылка на метод произвольного объекта конкретного типа(ContainingType::methodName);
* Ссылка на конструктор(ClassName::new), для дженериков Class<T>::new.

**7. ОБЪЯСНИТЕ ВЫРАЖЕНИЕ SYSTEM.OUT::PRINTLN?**

Ответ: Выражение System.out::println является ссылкой на статический метод println объекта out класса System, который эквивалентен лямбда-выражению x -> System.out.println(x).

**8. ЧТО ТАКОЕ ФУНКЦИОНАЛЬНЫЕ ИНТЕРФЕЙСЫ?**

Ответ: Функциональный интерфейс - это тот интерфейс, который определяет строго один абстрактный метод. В Java 8 была введена новая аннотация @FunctionalInterface для обозначения интерфейса функциональным, эта аннотация используется для того, чтобы избежать случайного добавления абстрактных методов в функциональный интерфейс. Функциональные интерфейсы позволяют использовать лямбда-выражения для создания экземпляра таких интерфейсов.

Пример функционального интерфейса будет интерфейс java.lang.Runnable с одним абстрактным методом run(). Заметим, интерфейс может включать сколько угодно default методов и при этом оставаться функциональным, потому что default-методы - не абстрактные.

**9. ОБЪЯСНИТЕ ДЛЯ ЧЕГО НУЖНЫ СЛЕДУЮЩИЕ ИНТЕРФЕЙСЫ.**

Ответ: 

* BiConsumer<T,U> - представляет собой операцию, которая принимает 2 входных параметра, и не возвращает никакого результата;
* BiFunction<T,U,R> - представляет собой функцию, которая принимает 2 аргумента и возращает результат;
* BinaryOperator<T> - представляет собой операцию над двумя операндами одного и того же типа, выполняет над ними бинарную операцию и возвращает результат тогоже типа, что и операнды;
* BiPredicate<T,U> - представляет собой результат(булеву функцию) 2 аргументов;
* BooleanSupplier|DoubleSupplier - представляет собой поставщика булевых|double результатов;
* Consumer<T> - представляет собой операцию, которая принимает один входной аргумент, выполняет некоторое действие над объектом типа Т, при этом ничего не возвращая;
* DoubleBinaryOperator - представляет собой операцию над 2 операндами типа double, возвращает результат типа double;
* DoubleConsumer - представляет собой операцию, которая принимает один аргумент типа double, и не возвращает результат;
* DoubleFunction<R> - представляет собой функцию, которая принимает один аргумент типа double, и возвращает результат;
* DoublePredicate - представляет собой предикат(булеву функцию) одного аргумента типа double;
* DoubleToIntFunction - представляет собой функцию, которая принимает один аргумент типа double, возвращает результат типа int;
* DoubleToLongFunction - представляет собой функцию, которая принимает один аргумент типа double, возвращает результат типа long;
* DoubleUnaryOperator - представляет собой операцию над одним аргументом типа double, возвращает результат типа double;
* Function<T,R> - представляет собой функцию перехода от объекта типа Т к объекту типа R;
* IntBinaryOperator - представляет собой операцию над 2 операндами типа int, возвращает результат типа int;
* IntConsumer - представляет собой операцию, которая принимает один аргумент типа int, и не возвращает результат;
* IntFunction<R> - представляет собой операцию, которая принимает один аргумент типа int, возвращает результат;
* IntPredicate - представляет собой предикат(булеву функцию) одного аргумента типа int;
* IntSupplier - представляет собой поставщика int результатов;
* IntToDoubleFunction - представляет собой функцию, которая принимает один аргумент типа int, возвращает результат типа double;
* IntToLongFunction - представляет собой функцию, которая принимает один аргумент типа int, возвращает результат типа long;
* IntUnaryOperator - представляет собой операцию над одним аргументом типа int, возвращает результат типа int;
* LongBinaryOperator - представляет собой операцию над 2 операндами типа long, возвращает результат типа long;
* LongConsumer - представляет собой операцию, которая принимает один аргумент типа long, не возвращает результат;
* LongFunction<R> - представляет собой функцию, которая принимает один аргумент  типа long, и возвращает результат;
* LongPredicate - представляет собой предикат(булеву функцию) одного аргумента типа long;
* LongSupplier - представляет собой поставщика long результатов;
* LongToDoubleFunction - представляет собой функцию, которая принимает один аргумент типа long, и возвращает результат типа double;
* LongToIntFunction -  представляет собой функцию, которая принимает один аргумент типа long, и возвращает результат типа int;
* LongUnaryOperator -  представляет собой операцию над oдним аргументом типа long, возвращает результат типа long;
* ObjDoubleConsumer<T> - представляет собой операцию, которая принимает  один аргумент типа Object, и второй типа double, и не возвращает результат;
*  ObjIntConsumer<T> - представляет собой операцию, которая принимает  один аргумент типа Object, и второй типа int, и не возвращает результат;
*  ObjLongConsumer<T> - представляет собой операцию, которая принимает  один аргумент типа Object, и второй типа long, и не возвращает результат;
* Predicate<T> - представляет собой предикат(булеву функцию) одного аргумента;
* Supplier<T> - представляет собой поставщика результатов;
* ToDoubleBiFunction<T,U> - представляет собой функцию, которая принимает 2 аргумента, возвращает результат типа double;
* ToDoubleFunction<T> - представляет собой функцию, которая принимает один аргумент, возвращает результат типа double;
* ToDoubleBiFunction<T,U> - представляет собой функцию, которая принимает 2 аргумента, возвращает результат типа int;
* ToIntFunction<T> - представляет собой функцию, которая принимает один аргумент, возвращает результат типа int;
* ToLongBiFunction<T,U> - представляет собой функцию, которая принимает 2 аргумента, возвращает результат типа long;
* ToLongFunction<T> - представляет собой функцию, которая принимает один аргумент, возвращает результат типа long;
* UnaryOperator<T> - представляет собой операцию над одним операндом, возвращает результат того же типа, что и операнд.

**10. ЧТО ТАКОЕ STRINGJOINER?**

Ответ: StringJoiner используется, чтобы создать последовательность символов, разделенных разделителем, может(не обязательно)  начинаться с префикса и заканчиваться суффиксом.

![](https://3.bp.blogspot.com/-ehxpY3b1xho/VzlRJnsNI7I/AAAAAAAAAq4/lMjQXjdQgQQrDDNbZzExdPk4K8anJcgDwCLcB/s1600/q052_p01.jpg)

**11. ЧТО ТАКОЕ DEFAULT МЕТОДЫ?**

Ответ: Начиная с Java 8 мы можем использовать стандартные(default) и статические(static) методы. Default методы - это метод в интерфейсе с по умолчанию реализованной логикой, который не требуется обязательно определять в реализации этого интерфейса.

![](https://1.bp.blogspot.com/-5jBnBJfF3LA/VzlRUYhJPqI/AAAAAAAAAq8/e0nsTvTR6GQHp0KPJ88RPMhgJx1f0bB_ACLcB/s1600/q053_p01.jpg)

**12. ЧТО ТАКОЕ STATIC МЕТОДЫ?**

Ответ: Static-методы в интерфейсе - похожи на static-методы в абстрактном классе.

* Статические методы в интерфейсе являются частью интерфейса, мы не можем его использовать для объектов класса реализации;
* Статические методы в интерфейсе хороши для обеспечения    вспомогательных методов, например, проверки на null,сортировки коллекций и т.д.;
* Статические методы в интерфейсе помогают обеспечивать безопасность, не позволяя классам, которые реализуют интерфейс, переопределить их;
* Мы не можем определить статические методы  для методов класса Object, потому что получим ошибку компиляции.

**13. КАК ВЫЗВАТЬ DEFAULT-МЕТОД ИНТЕРФЕЙСА В КЛАССЕ?**

Ответ: Используя ключевое слово super вместе с именем интерфейса.

![](https://4.bp.blogspot.com/-LiapsEILqKs/VzlSY3BKxzI/AAAAAAAAArM/jutVU1ZbwIQc4gyg--968UDthowXMvufQCLcB/s1600/q055_p01.jpg)

**14. КАК ВЫЗВАТЬ STATIC-МЕТОД ИНТЕРФЕЙСА В КЛАССЕ?**

Ответ: Используя имя интерфейса.

![](https://3.bp.blogspot.com/-PPhp7ifrB44/VzlSxyAAFDI/AAAAAAAAArU/8dlj0whJncgBDgMLaPDzUSWMxXH4fIXqQCLcB/s1600/q056_p01.jpg)

**15. ЧТО ТАКОЕ ПОТОКИ(STREAM) В JAVA?**

Ответ: java.util.stream - введен  для поддержки распараллеливания вычислений в потоках. Предоставляет возможность обрабатывать последовательность элементов исполняя одну или несколько операций, которые могут выполняться либо последовательно либо параллельно. 

Потоки делятся на последовательные и параллельные.Самая большая польза от этого - работа с коллекциями.

Операции над потоком относятся либо к промежуточным, либо к терминальным. Все промежуточные операции возвращают поток, так что мы может объединять несколько промежуточных операций без использования точки с запятой. Терминальные операции возвращают void или непотоковый результат.

**16. ДЛЯ ЧЕГО НУЖЕ МЕТОД COLLECT JAVA 8?**

Ответ: Большинство операций класса Stream, который модифицируют набор данных, возвращают этот набор в виде потока. Однако бывают ситуации, когда хотелось бы получить данные не в виде потока, а в виде обычной коллекции. И для этого в классе Stream опеределен метод collect(). Метод принимает в качестве параметра функцию преобразования к коллекции: *<R,A> R collect(Collector<? super T,A,R> collector)*.

Параметр R представляет тип результата метода, параметр Т - тип элемента в потоке, параметр А - тип промежуточных накапливаемых данных. В итоге  параметр collector представляет функцию преобразования потока в коллекцию.

**17. В ЧЕМ РАЗНИЦА МЕЖДУ КОЛЛЕКЦИЕЙ(COLLECTION) И ПОТОКОМ(STREAM)?**

Ответ: Разница между коллекций данных и потоков из новой JDK8 в том, что коллекции  позволяют работать с элементами по-отдельности, тогда как поток не позволяет. Например, с использованием коллекций, вы можете добавлять элементы, удалять и вставлять в середину. Поток не позволяет манипулировать отдельными элементами из набора данных, но вместо этого позволяет выполнять функции над данными как одним целом.

**18. ДЛЯ ЧЕГО ПРЕДНАЗНАЧЕН МЕТОД FOREACH В ПОТОКАХ(STREAM)?**

Ответ: Метод void forEach(Consumer<? super T> action) - для каждого элемента выполняется действие action. forEach является терминальной операцией, используется для перебора каждого элемента потока. forEach не гарантирует последовательности вывода элементов в параллельном потоке, для этого используется forEachOrdered - он это гарантирует.



