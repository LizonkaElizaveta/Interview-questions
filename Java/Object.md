**1. Какие методы есть  у класса Object?**

Ответ: 
* public final native Class getClass() — возвращает в рантайме класс данного объекта.
* public native int hashCode() — возвращает хеш-код.
* public boolean eguals(Object obj) — сравнивает объекты.
* protected native Object clone() throws CloneNotSupportedException — клонирование объекта.
* public String toString() — возвращает строковое представление объекта.
* public final native void notify() — просыпается один поток, который ждет на “мониторе” данного объекта.
* public final native void notifyAll() — просыпаются все потоки, которые ждут на “мониторе” данного объекта.
* public final native void wait(long timeout) throws InterruptedException — поток переходит в режим ожидания в течение указанного времени.
* public final void wait(long timeout, int nanos) throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() для этого метода, или пока не истечет указанный промежуток времени.
* public final void wait() throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() методы для этого объекта.
* protected void finalize() throws Throwable — вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет.

**2. Правила переопределения метода Object.equals() и Object.hashCode()?**

Ответ: 

* Рефлексивность: Объект должен равняться себе самому.
* Симметричность: если a.equals(b) возвращает true, то b.equals(a) должен тоже вернуть true.
* Транзитивность: если a.equals(b) возвращает true и b.equals(c) тоже возвращает true, то c.equals(a) тоже должен возвращать true.
* Согласованность: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено. То есть, если два объекта равны в Java, то они будут равны пока их свойства остаются неизменными.
* Сравнение null: объект должны быть проверен на null. Если объект равен null, то метод должен вернуть false, а не NullPointerException. Например, a.equals(null) должен вернуть false.

**3. Какая связь между hashCode и equals?**

Ответ: Если объекты равны по результатам выполнения метода equals, тогда их hashcode должны быть одинаковыми.

Если объекты не равны по результатам выполнения метода equals, тогда их hashcode могут быть как одинаковыми, так и разными. Однако для повышения производительности, лучше, чтобы разные объекты возвращали разные коды.

**4. Как переопределять метод equals и hashCode?**

Ответ: 
``` java
public int id;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Main)) return false;
        Main main = (Main) o;
        return id == main.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
```

Общий алгоритм определения equals:
1. Проверить на равенство ссылки объектов this и параметра метода o.
```java 
if (this == o) return true; 
```
2. Проверить, определена ли ссылка o, т. е. является ли она null.
Если в дальнейшем при сравнении типов объектов будет использоваться оператор instanceof, этот пункт можно пропустить, т. к. этот параметр возвращает false в данном случае null instanceof Object.
3. Сравнить типы объектов this и o с помощью оператора instanceof или метода getClass().
4. Если метод equals переопределяется в подклассе, не забудьте сделать вызов super.equals(o)
5. Выполнить преобразование типа параметра o к требуемому классу.
6. Выполнить сравнение всех значимых полей объектов:
   * для примитивных типов (кроме float и double), используя оператор ==
   * для ссылочных полей необходимо вызвать их метод equals
   * для массивов можно воспользоваться перебором по циклу, либо методом Arrays.equals()
   * для типов float и double необходимо использовать методы сравнения соответствующих оберточных классов Float.compare() и Double.compare()
7. И, наконец, ответить на три вопроса: является ли реализованный метод симметричным? Транзитивным? Согласованным? Два других принципа (рефлексивность и определенность), как правило, выполняются автоматически.


**5. Каким образом реализованы методы hashCode и equals в классе Object?**

Ответ: Реализация метода equals в классе Object сводится к проверке на равенство 2 ссылок:
``` java
public boolean equals(Object obj) {
        return (this == obj);
    }
```
Реализация  метода hashCode в классе Object сделана нативной, т.е. определенной не с помощью Java-кода. Он обычно возращает адрес объекта в памяти:
``` java
 public native int hashCode();
```

**6. Что будет, если переопределить equals, не переопределяя hashCode? Какие могут возникнуть проблемы?**

Ответ: Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать. Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.

**7. Есть ли какие-либо рекомендации о том, какие поля  следует использовать при подсчете hashCode?**

Ответ: Необходимо использовать уникальные, лучше примитивные поля, такие как id, uuid. Причем если эти поля задейстованы при вычислении hashCode, то нужно их задействовать при вычислении equals.

**8. Для чего нужен метод hashCode?**

Ответ: У метода equals() есть большой минус – он слишком медленно работает. Для этого был придуман метод hashCode(). Для каждого объекта данный метод возвращает определенное число. Вместо того чтобы сравнивать объекты, будем сравнивать их hashCode, и только если hashCode-ы равны, сравнивать объекты посредством equals(). 

Дело в том, что коллекции в Java перед тем как сравнить объекты с помощью equals всегда ищут/сравнивают их с помощью метода hashCode(). И если у одинаковых объектов будут разные hashCode, то объекты будут считаться разными — до сравнения с помощью equals() просто не дойдет.

**9. Расскажите про клонирование объектов? В чем  отличие между поверхностным и глубоким клонированием?**

Ответ: Методо clone() позволяет создавать объект с аналогичной структурой, как и у исходного объекта. Чтобы объект можно было клонировать, он должен реализовывать интерфейс Cloneable(маркер).

Поверхностное копирование копирует настолько малую часть информации, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует. При клонировании, JVM делает такие вещи:   
* Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.
* Если класс содержит не только члены примитивных типов, а и любого другого типа класса, тогда копируются ссылки на объекты этих классов. Следовательно, оба объекта будут иметь одинаковые ссылки.

Для того, чтобы произвести глубокое клонирование, необъодимо в клонируемом классе переопределить метод clone().Глубокое копирование дублирует все. Глубокое копирование — это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции. Мы хотим сделать копию, при которой внесение изменений в любой элемент копии не затронет оригинальную коллекцию.

Глубокое клонирование требует выполнения следующих правил:
* Нет необходимости копировать отдельно примитивные данные;
* Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться super.clone() при переопределении метода clone();
* Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.

**10. Правила переопределения метода Object.clone()?**

Ответ: Метод clone() в Java используется для клонирования объектов. Т.к.  Java работает с объектами с помощью ссылок, то простым присваиванием  тут не обойдешься, ибо в любом случае копируется лишь адрес, и мы получаем две ссылки на один и тот же объект, а не то, что нам нужно. clone() действует как конструктор копирования. Обычно он вызывает метод super.clone().

Object.clone() кидает исключение CloneNotSupportedException, если вы пытаетесь клонировать объект не реализующий интерфейс Cloneable.

Метод clone() несовместим с final полями. Если вы попытаетесь клонировать final поле, то компилятор остановит вас.

![](https://4.bp.blogspot.com/-kNerO5PAWMI/V52kxm5A_fI/AAAAAAAAA_U/sh1UHOUbMyEYikGPvbMM-X_U_QZqQCEGgCEw/s1600/q040_p03.jpg)
![](https://3.bp.blogspot.com/-4jznYjVR3CE/V52lLdqcWyI/AAAAAAAAA_Q/c1UgZdztQvwZFi6S4iwGOeAMl7dqudHlQCLcB/s1600/q040_p04.jpg)

**11. Опишите метод Object.finalize()?**

Ответ: Метод обеспечивает механизм, который является аналогичным  использованию деструкторов в С++, который может использоваться для того, чтобы произвести процесс очистки перед возвращением управления ОС. Применяя метод finalize(), можно определять специальные действия, который будут выполняться тогад, когда объект будет использоваться сборщиком мусора. В классе Object о ничего не делает, однако в классе-наследнике позволяет описать все действия, необходимые для корректного удаления объекта, такие как закрытия соединения с БД, сетевых соединений, снятие блокировок на файлы и тд. В обычным режиме напрямую этот метод вызывать не нужно, он отработает автоматически.

**12. Чем отличаются слова final, finally, finalize?**

Ответ: final - нельзя наследоваться от final класса; нельзя переопределить final метод; нельзя изменить значение final поля.

finally - используется при обработки ошибок, вызывается всегда, даже если произошла ошибка; удобно использовать при освобождении ресурсов.

finalize - вызывается перед тем, как свобщик мусора будет проводить освобождение памяти.
