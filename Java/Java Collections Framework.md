**1. ЧТО ТАКОЕ КОЛЛЕКЦИЯ?**

Ответ: Коллекция - это хранилища или контейнеры, поддерживающие различные способы накопления и упорядочения объектов с целью обеспечения возможностей эффективного доступа к ним. Они представляют собой реализацию абстрактных структур данных, поддерживающих 3 основные операции: добавление нового элемента, удаление элемента из коллекции и  изменение элемента в коллекции.

**2. НАЗОВИТЕ ОСНОВНЫЕ ИНТЕРФЕЙСЫ КОЛЛЕКЦИЙ И ИХ ИМПЛЕМЕНТАЦИИ?**

Ответ: 

![](http://javastudy.ru/wp-content/uploads/2016/01/CollectionsHierarchy.png)

Collection раширяет 3 интерфейса: List, Set, Queue.

List - хранит упорядоченные элементы(м.б. одинаковыми).

* Vector - синхронизирован, поэтому в одном потоке он работает медленней остальных реализаций
* ArrayList - его преимущество в навигации по коллекции
* LinkedList - его преимущество во вставке и удалении элементов

Set - коллекции, которые не содержат повторяющихся элементов. 

* TreeSet - упорядочивает элементы по их значениям
* HashSet - упорядочивает элементы по их хэш-ключам
* LinkedHashSet - хранит элементы в порядке их добавления

Queue - интерфейс для реализации очередей в Java(FIFO - first in first out).

* LinkedList
* PriorityQueue

Map - интерфейс для реализации карты, где элементы хранятся в виде ключ-значение. Ключи не могут быть одинаковыми

* HashTable - синхронизированна, объявлена устаревшей
* HashMap - порядок эелментов рассчитывается по хэш-ключу
* TreeMap - элементы хранятся  в отсортированном порядке
* LinkedHashMap - элементы хранятся в порядке вставки

**3. ЧЕМ ОТЛИЧАЕТСЯ ARRAYLIST ОТ LINKEDLIST? В КАКИХ СЛУЧАЯХ ЛУЧШЕ ИСПОЛЬЗОВАТЬ ПЕРВЫЙ, А В КАКИХ ВТОРОЙ?**

Ответ: Отличие заключается в способе хранения данных. ArrayList хранит в виде массива, LinkedList в виде двунаправленного списка.

ArrayList следует использовать, когда в приоритете доступ по индексу, так как эти операции выполняются за константное время. Добавление в конец списка в среднем тоже выполняется за константное время. Кроме того, в ArrayList нет дополнительных расходов на хранение связки между элементами. Минусы в скорости вставки/удаления элементов находящихся не в конце списка, т.к. при этой операции, все элементы правее добавляемого/удаляемого сдвигаются.

LinkedList удобен когда важнее быстродействие операций вставки/удаления, которые в LinkedList выполняются за константное время. Операции доступа по индексу производятся перебором с начала или конца (смотря, что ближе) до нужного элемента. Дополнительные затраты на хранение связки между элементами.

**4. ЧЕМ ОТЛИЧАЕТСЯ HASHMAP ОТ HASHTABLE?**

Ответ: Главное отличие этих классов в том, что HashTable синхронизирован, а HashMap - нет. Кроме этого, класс HashMap разрешает использование null в качестве ключей и значений.

Наличие синхронизации уменьшает производительность кода, использующего данный класс. Начиная с Java 6 JCF был расширен специальными коллекциями, поддерживающими многопоточный доступ, такими как CopyOnWriteArrayList и ConcurrentHashMap.

**5. ЧЕМ ОТЛИЧАЕТСЯ ARRAYLIST ОТ VECTOR?**

Ответ: Методы класса Vector синхронизированы в отличии от ArrayList.

**6. КАК СРАВНИВАЮТСЯ ЭЛЕМЕНТЫ КОЛЛЕКЦИЙ?**

Ответ: для сравнения элементов коллекций используется метод equals() и hashCode().

**7. РАСПОЛОЖИТЕ В ВИДЕ ИЕРАРХИИ СЛЕДУЮЩИЕ ИНТЕРФЕЙСЫ: LIST, SET, MAP, SORTEDSET, SORTEDMAP, COLLECTION, ITERABLE, ITERATOR, NAVIGABLESET, NAVIGABLEMAP?**

Ответ:

![](https://4.bp.blogspot.com/-Q_s7doySHYI/VpH_bPyXoXI/AAAAAAAAAHU/V719xtIumUs/s400/collection_hierarchy.jpg)

**8. ПОЧЕМУ MAP - ЭТО НЕ COLLECTION, В ТО ВРЕМЯ КАК LIST И SET ЯВЛЯЮТСЯ COLLECTION?**

Ответ: Коллекция(List,Set) представляет собой совокупность некоторых элементов(обычно экземпляров одного класса). Map - это совокупность пар "ключ-значение". Соответственно некоторые методы интерфейса Collection нельзя использовать в Map. Например, метод remove(Object o) в интерфейсе Collection предназначен для удаления элемента, тогда как такой же метод в интерфейсе Map - удаляет элемент по заданному ключу.

**9. ДАЙТЕ ОПРЕДЕЛЕНИЕ ПОНЯТИЮ ITERATOR?**

Ответ: Итератор - элемент, позволяющие перебирать элементы коллекции(например, foreach реализован с использованием итератора). 

![](https://4.bp.blogspot.com/-1RyU_iZNL4M/WE7xZ_fAD0I/AAAAAAAABYc/2RnSl9WBWtomiYAIE-tXaGWDzM8csnA-ACLcB/s640/iterator.jpg)

**10. ЧТО ВЫ ЗНАЕТЕ ОБ ИНТЕРФЕЙСЕ ITERABLE?**

Ответ: Все коллекции из java.util реализуют интерфейс Collection, который расширяет интерфейс Iterable. В интерфейсе Iterable описан только один метод - Iterator iterator().

**11. КАК ОДНОЙ СТРОЧКОЙ ПРЕОБРАЗОВАТЬ HASHSET В ARRAYLIST?**

Ответ:

![](https://1.bp.blogspot.com/-TeYrTL28gYw/VpIBpevG7tI/AAAAAAAAAHc/DnUckW4fB1M/s400/hashSet_to_arrayList.jpg)

**12. КАК ОДНОЙ СТРОЧКОЙ ПРЕОБРАЗОВАТЬ ARRAYLIST В HASHSET?**

Ответ:

![](https://1.bp.blogspot.com/-CsKJw9MKV9M/VpIB4KnTCZI/AAAAAAAAAHk/7F4BhFUEBCM/s400/arrayList_to_hashSet.jpg)

**13. КАК ПЕРЕБРАТЬ ВСЕ КЛЮЧИ MAP, УЧИТЫВАЯ, ЧТО MAP - ЭТО НЕ ITERABLE?**

Ответ: Использовать метод keySet(), который возвращает множество (Set<K>) ключей.

**14. КАК ПЕРЕБРАТЬ ВСЕ ЗНАЧЕНИЯ MAP, УЧИТЫВАЯ, ЧТО MAP - ЭТО НЕ ITERABLE?**

Ответ: Использовать метод values(), который возвращает коллекцию (Collection<V>) значений.

**15. КАК ПЕРЕБРАТЬ ВСЕ ПАРЫ КЛЮЧ-ЗНАЧЕНИЕ В MAP, УЧИТЫВАЯ, ЧТО MAP - ЭТО НЕ ITERABLE?**

Ответ: Использовать метод entrySet(), который возвращает множество (Set<Map.Entry><K,V>) пар ключ-значение.

**16. В ЧЕМ ПРОЯВЛЯЕТ СОРТИРОВАННОСТЬ SORTEDMAP?**

Ответ: Интерфейс SortedMap расширяет Map и создает отображение, в котором все элементы отсортированы в порядке возрастания их ключей.

**17. КАКИМ ОДНИМ ВЫЗОВОМ КОПИРОВАТЬ ЭЛЕМЕНТЫ ИЗ ЛЮБОЙ COLLECTION В МАССИВ?**

Ответ:

![](https://1.bp.blogspot.com/-D1Swg0zDSYw/VpIDH0shNdI/AAAAAAAAAHw/d2-5Jm7xh_Q/s640/collection_to_array.jpg)

**18. РЕАЛИЗУЙТЕ СИММЕТРИЧЕСКУЮ РАЗНОСТЬ ДВУХ КОЛЛЕКЦИЙ, ИСПОЛЬЗУЯ МЕТОДЫ COLLECTION (ADDALL(),REMOVEALL(),RETAINALL())?**

Ответ:Симметрическая разность двух коллекций - это множество элементов, одновременно не принадлежащих обоим исходным коллекциям.

![](https://1.bp.blogspot.com/-tO8NHPp0eC8/VpIDezzKqaI/AAAAAAAAAH4/4HeaQHAMWuM/s640/symmetric_difference_collection.jpg)

**19. СРАВНИТЕ ENUMERATION И ITERATOR?**

Ответ: Оба интерфейса предназначены для обхода коллекций. Интерфейс Iterator был введен несколько позднее в JCF. Основные различия:
 
 * наличие метода remove() для удаления элемента при обходе
 * исправлены имена методов для повышения читаемости кода

**20. КАК МЕЖДУ СОБОЙ СВЯЗАНЫ ITERABLE И ITERATOR?**

Ответ: Интерфейс Iterable имеет только один метод iterator(), который возвращает итератор коллекции для её обхода.

**21. СРАВНИТЕ ITERATOR И LISTITERATOR?**

Ответ: ListIterator расширяет интерфейс  Iterator, позволяя клиенту осуществлять обход коллекции в обоих направлениях, изменять коллекцию и получать текущую позицию итератора.

При этом важно помнить, что ListIterator не указывает на конкретный элемент, а его текущая позиция располагется между элементами, которые возвращают методы previous() и next(). Т.об., модификация коллекции осуществляется для последнего элемента, который был возвращен мтодами previous() и next().

**22. ЧТО ПРОИЗОЙДЕТ, ЕСЛИ Я ВЫЗОВУ ITERATOR.NEXT() НЕ СПРОСИВ ITERATOR.HASNEXT()?**

Ответ: Если итератор указывает на последний элемент коллекции, то возникнет исключение NoSuchElementException, иначе будет возращен следующий элемент.

**23. ЕСЛИ У МЕНЯ ЕСТЬ КОЛЛЕКЦИЯ И ПОРОЖДЕННЫЙ ИТЕРАТОР, ИЗМЕНИТСЯ ЛИ КОЛЛЕКЦИЯ, ЕСЛИ Я ВЫЗОВУ ITERATOR.REMOVE()?**

Ответ: Вызов метода Iterator.remove() возможен только после вызова метода iterator.next(), хотя бы раз, иначе появится исключение IllegalStateException(). Если Iterator.next() был вызван прежде, то iterator.remove() удалит элемент, но который указывает итератор.

**24. ЕСЛИ У МЕНЯ ЕСТЬ КОЛЛЕКЦИЯ И ПОРОЖДЕННЫЙ ИТЕРАТОР, ИЗМЕНИТСЯ ЛИ ИТЕРАТОР, ЕСЛИ Я ВЫЗОВУ COLLECTION.REMOVE()?**

Ответ: Итератор не изменится, но при следующем вызове его методов возникнет исключение ConcurrentModificationException.

**25. В РЕАЛИЗАЦИИ КЛАССА ARRAYLIST ЕСТЬ СЛЕДУЮЩИЕ ПОЛЯ: OBJECT(), ELEMENTDATA, INT SIZE. ЗАЧЕМ ХРАНИТЬ ОТДЕЛЬНО SIZE, ЕСЛИ ВСЕГДА МОЖНО ВЗЯТЬ ELEMENTDATA.LENGHT?**

Ответ: Размер массива elementData представляет собой вместимость(capacity) ArrayList, которая всегда больше переменной size - реального количества хранимых элементов. С добавлением новых элементов вместимость автоматически возрастает при необходимости.

**26. КАКОЕ ХУДШЕЕ ВРЕМЯ РАБОТЫ МЕТОДА CONTAIN() ДЛЯ ЭЛЕМЕНТА, КОТОРЫЙ ЕСТЬ В LINKEDLIST/ARRAYLIST?**

Ответ: LinkedList - O(n), ArrayList - O(n). Время поиска элемента линейно  пропорционально количеству элементов в списке.

**27. КАКОЕ ХУДШЕЕ ВРЕМЯ РАБОТЫ МЕТОДА ADD() ДЛЯ LINKEDLIST/ ARRAYLIST?**

Ответ: LinkedList - O(n), при добавление элемента в отсортированный список, а также при добавлении элемента с помощью метода add(index, value). Добавление элемента в конец списка с помощью метода add(value), addLast(value) и добавление в начало списка с помощью метода addFirst(value) выполняется за время O(1).

ArrayList - O(n). Вставка элемента в конец списка происходит за время O(1), но если вместимость массива недостаточна, то происходит создание нового массива с увеличенным размером и копирование всех элементов из старого массива в новый.

**28. СКОЛЬКО ВЫДЕЛЯЕТСЯ ЭЛЕМЕНТОВ В ПАМЯТИ ПРИ ВЫЗОВЕ ARRAYLIST.ADD()/LINKEDLIST.ADD()?**

Ответ: Если в массиве ArrayList достаточно места для размещения нового элемента, то дополнительно место в памяти не выделяется. Иначе происходит создание нового массива размером(в JDK 1.7 умножение старого размера  на 1.5): 
![](https://4.bp.blogspot.com/-UNyV-9oBSTU/VpI68-iVjEI/AAAAAAAAAII/hav8p8WE44Q/s1600/arrayList_capacity.jpg)

Для LinkedList - создается один новый экземпляр класса Node.

**29. ОЦЕНИТЕ КОЛИЧЕСТВО ПАМЯТИ НА ХРАНЕНИЕ ОДНОГО ПРИМИТИВА ТИПА BYTE В LINKEDLIST?**

Ответ: Каждый элемент в LinkedList хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные. 
``` java
private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;
//...
}
```
Для 32-битных систем каждая ссылка занимает 32 бита (4 байта). Сам объект (заголовок) вложенного класса Node занимает 8 байт. 4 + 4 + 4 + 8 = 20 байт, а т.к. размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа byte занимает 1 байт памяти, но в JCF примитивы упаковываются: объект типа Byte занимает в памяти 16 байт (8 байт на заголовок объекта, 1 байт на поле типа byte и 7 байт для кратности 8). Также напомню, что значения от -128 до 127 кэшируются и для них новые объекты каждый раз не создаются. Таким образом, в x32 JVM 24 байта тратятся на хранение одного элемента в списке и 16 байт - на хранение упакованного объекта типа Byte. Итого 40 байт.

Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт), размер заголовка каждого объекта составляет 16 байт (два машинных слова). Вычисления аналогичны: 8 + 8 + 8 + 16 = 40байт и 24 байта. Итого 64 байта.

**30. ОЦЕНИТЕ КОЛИЧЕСТВО ПАМЯТИ НА ХРАНЕНИЕ ОДНОГО ПРИМИТИВА ТИПА BYTE В ARRAYLIST?**

Ответ: ArrayList основан на массиве, для примитивных типов данных осуществляется автоматическая упаковка значения, поэтому 16 байт тратится на хранение упакованного объекта и 4 байта (8 для x64) - на хранение ссылки на этот объект в самой структуре данных. Таким образом, в x32 JVM 4 байта используются на хранение одного элемента и 16 байт - на хранение упакованного объекта типа Byte. Для x64 - 8 байт и 24 байта соотвтетсвенно.

**31. Я ДОБАВЛЯЮ ЭЛЕМЕНТ В СЕРЕДИНУ LIST-A: LIST.ADD(LIST.SIZE()/2,NEWELEM). ДЛЯ КОГО ЭТА ОПЕРАЦИЯ МЕДЛЕННЕЕ - ДЛЯ ARRAYLIST ИЛИ LINKEDLIST?**

Ответ: Для ArrayList

* проверка массива на вместимость. Если вместимости недостаточно, то увеличение размера массива и копирование всех элементов в новый массив (O(n))
* копирование всех элементов, расположенных правее от позиции вставки, на одно позицию вправо (O(n/2))
* Вставка элемента (O(1))

Для LinkedList

* поиск позиции вставки (O(N/2))
* вставка элемента (O(1))

Операция медленнее для ArrayList, поскольку копирование элементов осуществляется за счет системного метода System.arraycopy().

**32. КАК ПЕРЕБРАТЬ ЭЛЕМЕНТЫ LINKEDLIST В ОБРАТНОМ ПОРЯДКЕ, НЕ ИСПОЛЬЗУЯ МЕДЛЕННЫЙ GET(INDEX)?**

Ответ: Использовать обратный итератор. Для этого в LinkedList есть метод descendingIterator().

**33. КАК ОДНИМ ВЫЗОВОМ ИЗ LIST ПОЛУЧИТЬ LIST СО ВСЕМИ ЭЛЕМЕНТАМИ, КРОМЕ ПЕРВЫХ И ПОСЛЕДНИХ 3-Х?**

Ответ: 
![](https://3.bp.blogspot.com/-mVQ17yKfz9I/VpI78CxFKhI/AAAAAAAAAIU/UaNOFZ-0mCc/s640/list_sublist.jpg)

**34. БУДЕТ ЛИ РАБОТАТЬ HASHMAP, ЕСЛИ ВСЕ КЛЮЧИ БУДУТ ВОЗВРАЩАТЬ INT HASHCODE() {RETURN 42;}?**

Ответ: Да, будет. Но тогда хэш-таблица вырождается в связный список и теряет свои преимущества.

**35. СОГЛАСНО КНУТУ И КОРМЕНУ СУЩЕСТВУЕТ ДВЕ ОСНОВНЫЕ РЕАЛИЗАЦИИ ХЭШ-ТАБЛИЦЫ: НА ОСНОВЕ ОТКРЫТОЙ АДРЕСАЦИИ(ЗАКРЫТОЕ ХЭШИРОВАНИЕ) И НА ОСНОВЕ МЕТОДА ЦЕПОЧЕК(ОТКРЫТОЕ ХЭШИРОВАНИЕ). КАК РЕАЛИЗОВАНА HASHMAP? ПОЧЕМУ ТАК СДЕЛАЛИ? В ЧЕМ МИНУСЫ И ПЛЮСЫ КАЖДОГО ПОДХОДА?**

Ответ: Класс HashMap реализован с использованием метода цепочек, т.е. каждой ячейке массива соответствует свой связный список и при возникновении коллизии осуществляется добавление нового элемента в этот список. 
Для метода цепочек коэффициент заполнения может быть больше 1, с увеличением числа элементов производительность убывает линейно. Такие таблицы удобно использовать, если заранее неизвестно количество хранимых элементов, либо их может быть достаточно много, что приводит к большим значениям коэффициента заполнения. 

Среди методов открытой реализации различают: 
*  линейное пробирование; 
*  квадратичное пробирование; 
* двойное хеширование. 

Основные недостатки структур с методом открытой адресации:

* Количество элементов в таблице не может превышать размера массива. По мере увеличения числа элементов в таблице и повышения коэффициента заполнения (load factor) производительность структуры резко падает, поэтому необходимо проводить перехеширование. 
*  Сложно организовать удаление элемента. 
* Также первые два метода открытой адресации приводят к проблеме первичной и вторичной группировок. 
Основное преимущество хэш-таблицы с открытой адресацией - это отсутствие затрат на создание и хранение объектов списка. Также проще организовать сериализацию/десериализацию объекта. 

https://ruhighload.com/%D0%A7%D1%82%D0%BE+%D1%82%D0%B0%D0%BA%D0%BE%D0%B5+%D1%85%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B+%D0%B8+%D0%BA%D0%B0%D0%BA+%D0%BE%D0%BD%D0%B8+%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%82

**36. СКОЛЬКО СОЗДАЕТСЯ НОВЫХ ОБЪЕКТОВ, КОГДА ВЫ ДОБАВЛЯЕТЕ НОВЫЙ ЭЛЕМЕНТ В HASHMAP?**

Ответ: Один новый объект статического вложенного класса Entry<K,V>.

**37. КАК РАБОТАЕТ HASHMAP ПРИ ПОПЫТКЕ СОХРАНИТЬ В НЕЕ ДВА ЭЛЕМЕНТА  ПО КЛЮЧАМ С ОДИНАКОВЫМ HASHCODE, НО ДЛЯ КОТОРЫХ EQUALS == FALSE?**

Ответ: По значению hashCode() вычисляется  индекс ячейки массива, в список  которой будет происходить добавление элемента. Перед добавлением осуществляется проверка на наличие уже элементов в этой ячейке. Если элементов нет, то происходит добавление. Если возникает коллизия, то итеративно осуществляется обход списка в поиска элемента с таким ж ключом и хэш-кодом. Если такой элемент найден, то его значение перезаписывается, а старое - возращается. Поскольку в условии сказано, что добавляемые ключи - разные, то второй элемент будет добавлен в начало списка.

**38. HASHMAP МОЖЕТ ВЫРОДИТСЯ В СПИСОК ДАЖЕ ДЛЯ КЛЮЧЕЙ С РАЗНЫМ HASHCODE. КАК ЭТО ВОЗМОЖНО?**

Ответ: Это возможно в случае, если метод, определяющий номер ячейки массива по hashCode будет возвращать одинаковое значение. 

**39. КАКОЕ ХУДШЕЕ ВРЕМЯ РАБОТЫ МЕТОДА GET(KEY) ДЛЯ КЛЮЧА, КОТОРОГО НЕТ(КОТОРЫЙ ЕСТЬ) В ТАБЛИЦЕ?**

Ответ: O(n) - поиск в списке(для обоих вариантов)

**40. ОБЪЯСНИТЕ СМЫСЛ ПАРАМЕТРОВ В КОСНТРУКТОРЕ HASHMAP(INT INITIALCAPACITY, FLOAT LOADFACTOR)?**

Ответ: int initialCapacity - исходный размер HashMap, по умолчанию имеет значение 16. float loadFactor - коэффициент запонения, равен отношению числа хранимых элементов в таблице к её размеру. При превышении количества хранимых таблицей значений, происходит автоматическое перехеширование. Значение по умолчанию 0.75 является хорошим компромиссом между временем доступа и объемом хранимых данных.

**41. В ЧЕМ РАЗНИЦА МЕЖДУ HASHMAP И IDENTITYHASHMAP? ДЛЯ ЧЕГО НУЖНА IDENTITYHASHMAP? КАК МОЖЕТ БЫТЬ ПОЛЕЗНА ДЛЯ РЕАЛИЗАЦИИ СЕРИАЛИЗАЦИИ  ИЛИ КЛОНИРОВАНИЯ?**

Ответ: IdentityHashMap - это структура данных, реализующая интерфейс Map, но использующая сравнение ссылок вместо метода equals(), который используется при сранение ключей/значений. IdentityHashMap не используется метод hashCode(), а использует System.identityHashCode(Object). Другое отличие IdentityHashMap от HashMap в производительности, т.к. последний хранит объекты с дорогостоящими методами equals() и hashCode().

Согласно документации, такая структура данных может применяться для реализации серриализации/клонирования. Для выполнения подобных алгоритмов программе необходимо обслуживать таблицу  со всеми ссылками на объекты, которые уже были обработаны. Такая таблица не должна рассматривать уникальные объекты как равные, даже если метод equals() возвращает true.

**42. В ЧЕМ РАЗНИЦА МЕЖДУ HASHMAP И WEAKHASHMAP? ДЛЯ ЧЕГО НУЖНА WEAKHASHMAP?**

Ответ: WeakHashMap - это структура данных, реализующая интерфейс Map и основанная на использовании WeakReference для хранения ключей. Т.об. пара ключ-значение будет удалена из WeakHashMap, если на объект-ключ нет сильных ссылок.

В качестве примера использования такой структуры даных  можно привести следующий пример: допустим имеются объекты, которые необходимо расширить дополнительной информацией, при этом изменение класса этиъ объектов нежелательно либо невозможно. В этом случае добавляем каждый объект в WeakHashMap в качестве ключа, а в качестве значения нужную информацию. Т.об., пока на объект имеется сильная(мягкая) ссылка, можно проверять хэш-таблицу и извлекать информацию. Как только объект будет удален, то WeakReference для этого ключа будет помещен в ReferenceQueue и затем соответствующая запись для этой ссылки будет удалена из WeakHashMap.

**43. СДЕЛАЙТЕ HASHSET ИЗ HASHMAP(ИСПОЛЬЗУЙТЕ ТОЛЬКО МНОЖЕСТВО КЛЮЧЕЙ, НО НЕ МНОЖЕСТВО ЗНАЧЕНИЙ)**

Ответ: 

![](https://4.bp.blogspot.com/-Sv0pX1KyJko/VpJCYIJfVjI/AAAAAAAAAJE/US-yTOA3rzA/s1600/hashSet%2B_from_hashMap.jpg)


**44. СДЕЛАЙТЕ HASHMAP ИЗ HASHSET(ИСПОЛЬЗУЙТЕ ТОЛЬКО МНОЖЕСТВО КЛЮЧЕЙ, НО НЕ МНОЖЕСТВО ЗНАЧЕНИЙ)**

Ответ: 

![](https://4.bp.blogspot.com/-lOJKZrixrJ8/VpJClmNwZ6I/AAAAAAAAAJM/GseVLENbW_U/s400/hashMap%2B_from_hashSet.jpg)

**45. СРАВНИТЕ ИНТЕРФЕЙСЫ JAVA.UTIL.QUEUE И JAVA.UTIL.DEQUE?**

Ответ: Согласно документации Deque(Double Ended Queue) - это линейная коллекция, поддерживающая вставку/извлечение элементов с обоих концов. Помимо этого реализация интерфейса Deque могут строится по принципу FIFO, либо LIFO.

Queue - это очередь, обычно(но не обязательно) строится по принципу FIFO - соответственно извлечение элемента осуществляется с начала очереди, вставка элемента в конец очереди. Этот принцип нарушает, к примеру, приоритетная очередь(PriorityQueue), использующая переданный comparator при вставке нового элемента, либо расстановка элементов осуществляется согласно естественному упорядочиванию.

Deque расширяет Queue.

Реализации Deque и Queue обычно не переопределяют метод equals() и hashCode(). Вместо этого используются  унаследованные методы класса Object, основанные на сранении ссылок.   

**46. ПОЧЕМУ LINKEDLIST РЕАЛИЗУЕТ И LIST, И DEQUE?**

Ответ: LinkedList позволяет добавлять элементы в начало и конец списка за константное время, что хорошо подходит для реализации интерфейса Deque.

**47. В ЧЕМ РАЗНИЦА МЕЖДУ КЛАССАМИ JAVA.UTIL.ARRAYS И JAVA.LANG.REFLECT.ARRAY?**

Ответ: java.util.Arrays - класс, содержащий статические методы для работы с массивами, таких как, например, поиск по массиву и его сортировка.

java.lang.reflect.Array - класс для работы с массивами при использовании рефлексии. Рефлексия - механизм, позволяющий исследовать данные о программе во время ее выполнения.

**48. В ЧЕМ РАЗНИЦА МЕЖДУ КЛАССАМИ JAVA.UTIL.COLLECTION И JAVA.UTIL.COLLECTIONS?**

Ответ: java.util.Collections содержит исключительно статические метода для работы с коллекциями. В них входят методы, реализующие полиморфные алгоритмы(такие алгоритмы, использование которых возможно с разными видами структур данных), "оболочки", возвращающие новую коллекцию с инкапсулированной указанной структурой данных и некоторые другие методы.

java.util.Collection - это корневой интерфейс Java Collections Framework. Этот интерфейс в основном применяется там, где требуется высокий уровень абстракции, например, в java.util.Collections.

**49. НАПИШИТЕ НЕМНОГОПОТОЧНУЮ ПРОГРАММУ, КОТОРАЯ ЗАСТАВЛЯЕТ КОЛЛЕКЦИЮ ВЫБРОСИТЬ CONCURENTMODIFICATIONEXCEPTION?**

Ответ: 

![](https://2.bp.blogspot.com/-Bg3zdJkPrjc/VpJE_HeR-8I/AAAAAAAAAJY/Euc_qBxNR6I/s1600/ConcurrentModificationException.jpg)

**50. ЧТО ТАКОЕ FAIL-FAST ПОВЕДЕНИЕ?**

Ответ: Fail-fast поведение означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает работу и уведомляет об этом.

В Java Collection API итераторы могут использовать fail-fast, либо fail-safe, либо weakly consistent. Итератор с fail-fast выбросит поведением выбросит исключение ConcurrentModificationException, если после  его создания была произведена модификация коллекции, т.е. добавлен или удален элемент(без использования метода remove() итератора). Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции(modification count):

* при изменении коллекции(удаление/добавление элемента) счетчик увеличивается
* при создании итератора ему передается текущее значение счетчика
* при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение

Использование fail-fast подхода позволяет избежать недетерминированного поведения программмы в течении времени. 

**51. JAVA.UTIL.STACK - СЧИТАЕТСЯ УСТАРЕВШИМ. ЧЕМ ЕГО РЕКОМЕНДУЮ ЗАМЕНЯТЬ? ПОЧЕМУ?**

Ответ: Рекомендуется использовать интерфейс Deque и его реализацию.

![](https://1.bp.blogspot.com/-KOu1mQeG524/VpJGC0CHUtI/AAAAAAAAAJk/aXGltaZaQLo/s1600/deque.jpg)

Стек - это структура данных, построенная на принципе LIFO. Каждое новое значение добавляется на вершину стека, а извлекается последний добавленный элемент(с вершины стека). При извлечении элемента он удаляется из структуры данных.

Класс Stack появился в JDK 1.0 и расширяет класс Vector, наследуя его функционал, что несколько нарушает понятие стека(например, класс Vector предоставляет возможность обращаться к любому элементу по индексу). Также использование Deque позволяет следовать принципу программирования на уровне интерфейсов, а не конкретных реализаций, что облегчает дальнейшую поддержку разрабатываемого класса и повышает его гибкость, позволяя при необходимости менять реализацию дека на нужную.

**52. ПРИВЕДИТЕ ПРИМЕР, КОГДА КАКАЯ-ЛИБО КОЛЛЕКЦИЯ ВЫБРАСЫВАЕТ UNSUPPORTEDOPERATIONEXCEPTION?**

Ответ: 

![](https://1.bp.blogspot.com/-xTlXoB9nDBw/VpJHGBYBzNI/AAAAAAAAAJw/ycXkcPPGQa0/s1600/UnsupportedOperationException.jpg)

Возникает UnsupportedOperationException, поскольку метода asList() возвращает список фиксированной длины, т.е. удаление/добавление элементов в такой список не поддерживается.

**53. ЧТО ТАКОЕ LINKEDHASHMAP? ЧТО В НЕМ ОТ LINKEDLIST, А ЧТО ОТ HASHMAP?**

Ответ: Реализация LinkedHashMap отличается от HashMap поддержкой двухсвязного списка, определяющего порядок итерации по элементам структуры данных. По умолчанию элемента списка упорядочены согласно их порядку добавления в LinkedHashMap. Однако порядок итерации можно изменить, установив параметр конструктора accessOrder в значение true. В этом случае доступ осуществляется  по порядку последнего обращения к элементу. Это означает, что при вызове методов get() или put() элемент, к которому обращаемся, перемещается в конец списка.

При добавлении элемента, который уже присутсвует в LinkedHashMap(т.е. с одинаковым ключом), порядок итерации по элементам не изменяется.

**54. ЧТО ТАКОЕ LINKEDHASHSET? ЧТО В НЕМ ОТ LINKEDLIST, А ЧТО ОТ HASHSET?**

Ответ: Реализация LinkedHashSet отличается от HashSet поддержкой двухсвязного списка, определяющего порядок итерации по элементам структуры данных. По умолчанию элемента списка упорядочены согласно их порядку добавления в LinkedHashSet. При добавлении элемента, который уже присутсвует в LinkedHashSet(т.е. с одинаковым ключом), порядок итерации по элементам не изменяется.

**55. ЧТО ПОЗВОЛЯЕТ СДЕЛАТЬ PRIORITYQUEUE?**

Ответ: PriorityQueue - структура данных, располагающая элементы в порядке натурального упорядочивания, либо используя переданный конструктор Comparator. Ипользуя PriorityQueue, можно, например, реализовать алгоритм Дейкстры ждя поиска кратчайшего пути от одной вершины графа  к другой. Либо применять для хранения объектов согласно их приоритету: например, сортировка пациентов врача - экстренные пациенты помещаются в начало очереди, менее срочный пациенты - ближе к концу очереди.

**56. В ЧЕМ ЗКЛЮЧАЕТСЯ ОТЛИЧИЕ JAVA.UTIL.COMPARATOR ОТ JAVA.UTIL.COMPARABLE?**

Ответ: Interface Comparable задает свойство сравнения объекту реализующему его. То есть делает объект сравнимым (по правилам разработчика). 

Interface Comparator позволяет создавать объекты, которые будут управлять процессом сравнения (например при сортировках).