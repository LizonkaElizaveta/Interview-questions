**1. ЧТО ТАКОЕ КОЛЛЕКЦИЯ?**

Ответ: Коллекция - это хранилища или контейнеры, поддерживающие различные способы накопления и упорядочения объектов с целью обеспечения возможностей эффективного доступа к ним. Они представляют собой реализацию абстрактных структур данных, поддерживающих 3 основные операции: добавление нового элемента, удаление элемента из коллекции и  изменение элемента в коллекции.

**2. НАЗОВИТЕ ОСНОВНЫЕ ИНТЕРФЕЙСЫ КОЛЛЕКЦИЙ И ИХ ИМПЛЕМЕНТАЦИИ?**

Ответ: 

![](http://javastudy.ru/wp-content/uploads/2016/01/CollectionsHierarchy.png)

Collection раширяет 3 интерфейса: List, Set, Queue.

List - хранит упорядоченные элементы(м.б. одинаковыми).

* Vector - синхронизирован, поэтому в одном потоке он работает медленней остальных реализаций
* ArrayList - его преимущество в навигации по коллекции
* LinkedList - его преимущество во вставке и удалении элементов

Set - коллекции, которые не содержат повторяющихся элементов. 

* TreeSet - упорядочивает элементы по их значениям
* HashSet - упорядочивает элементы по их хэш-ключам
* LinkedHashSet - хранит элементы в порядке их добавления

Queue - интерфейс для реализации очередей в Java(FIFO - first in first out).

* LinkedList
* PriorityQueue

Map - интерфейс для реализации карты, где элементы хранятся в виде ключ-значение. Ключи не могут быть одинаковыми

* HashTable - синхронизированна, объявлена устаревшей
* HashMap - порядок эелментов рассчитывается по хэш-ключу
* TreeMap - элементы хранятся  в отсортированном порядке
* LinkedHashMap - элементы хранятся в порядке вставки

**3. ЧЕМ ОТЛИЧАЕТСЯ ARRAYLIST ОТ LINKEDLIST? В КАКИХ СЛУЧАЯХ ЛУЧШЕ ИСПОЛЬЗОВАТЬ ПЕРВЫЙ, А В КАКИХ ВТОРОЙ?**

Ответ: Отличие заключается в способе хранения данных. ArrayList хранит в виде массива, LinkedList в виде двунаправленного списка.

ArrayList следует использовать, когда в приоритете доступ по индексу, так как эти операции выполняются за константное время. Добавление в конец списка в среднем тоже выполняется за константное время. Кроме того, в ArrayList нет дополнительных расходов на хранение связки между элементами. Минусы в скорости вставки/удаления элементов находящихся не в конце списка, т.к. при этой операции, все элементы правее добавляемого/удаляемого сдвигаются.

LinkedList удобен когда важнее быстродействие операций вставки/удаления, которые в LinkedList выполняются за константное время. Операции доступа по индексу производятся перебором с начала или конца (смотря, что ближе) до нужного элемента. Дополнительные затраты на хранение связки между элементами.

**4. ЧЕМ ОТЛИЧАЕТСЯ HASHMAP ОТ HASHTABLE?**

Ответ: Главное отличие этих классов в том, что HashTable синхронизирован, а HashMap - нет. Кроме этого, класс HashMap разрешает использование null в качестве ключей и значений.

Наличие синхронизации уменьшает производительность кода, использующего данный класс. Начиная с Java 6 JCF был расширен специальными коллекциями, поддерживающими многопоточный доступ, такими как CopyOnWriteArrayList и ConcurrentHashMap.

**5. ЧЕМ ОТЛИЧАЕТСЯ ARRAYLIST ОТ VECTOR?**

Ответ: Методы класса Vector синхронизированы в отличии от ArrayList.

**6. КАК СРАВНИВАЮТСЯ ЭЛЕМЕНТЫ КОЛЛЕКЦИЙ?**

Ответ: для сравнения элементов коллекций используется метод equals() и hashCode().

**7. РАСПОЛОЖИТЕ В ВИДЕ ИЕРАРХИИ СЛЕДУЮЩИЕ ИНТЕРФЕЙСЫ: LIST, SET, MAP, SORTEDSET, SORTEDMAP, COLLECTION, ITERABLE, ITERATOR, NAVIGABLESET, NAVIGABLEMAP?**

Ответ:

![](https://4.bp.blogspot.com/-Q_s7doySHYI/VpH_bPyXoXI/AAAAAAAAAHU/V719xtIumUs/s400/collection_hierarchy.jpg)

**8. ПОЧЕМУ MAP - ЭТО НЕ COLLECTION, В ТО ВРЕМЯ КАК LIST И SET ЯВЛЯЮТСЯ COLLECTION?**

Ответ: Коллекция(List,Set) представляет собой совокупность некоторых элементов(обычно экземпляров одного класса). Map - это совокупность пар "ключ-значение". Соответственно некоторые методы интерфейса Collection нельзя использовать в Map. Например, метод remove(Object o) в интерфейсе Collection предназначен для удаления элемента, тогда как такой же метод в интерфейсе Map - удаляет элемент по заданному ключу.

**9. ДАЙТЕ ОПРЕДЕЛЕНИЕ ПОНЯТИЮ ITERATOR?**

Ответ: Итератор - элемент, позволяющие перебирать элементы коллекции(например, foreach реализован с использованием итератора). 

![](https://4.bp.blogspot.com/-1RyU_iZNL4M/WE7xZ_fAD0I/AAAAAAAABYc/2RnSl9WBWtomiYAIE-tXaGWDzM8csnA-ACLcB/s640/iterator.jpg)

**10. ЧТО ВЫ ЗНАЕТЕ ОБ ИНТЕРФЕЙСЕ ITERABLE?**

Ответ: Все коллекции из java.util реализуют интерфейс Collection, который расширяет интерфейс Iterable. В интерфейсе Iterable описан только один метод - Iterator iterator().

**11. КАК ОДНОЙ СТРОЧКОЙ ПРЕОБРАЗОВАТЬ HASHSET В ARRAYLIST?**

Ответ:

![](https://1.bp.blogspot.com/-TeYrTL28gYw/VpIBpevG7tI/AAAAAAAAAHc/DnUckW4fB1M/s400/hashSet_to_arrayList.jpg)

**12. КАК ОДНОЙ СТРОЧКОЙ ПРЕОБРАЗОВАТЬ ARRAYLIST В HASHSET?**

Ответ:

![](https://1.bp.blogspot.com/-CsKJw9MKV9M/VpIB4KnTCZI/AAAAAAAAAHk/7F4BhFUEBCM/s400/arrayList_to_hashSet.jpg)

**13. КАК ПЕРЕБРАТЬ ВСЕ КЛЮЧИ MAP, УЧИТЫВАЯ, ЧТО MAP - ЭТО НЕ ITERABLE?**

Ответ: Использовать метод keySet(), который возвращает множество (Set<K>) ключей.

**14. КАК ПЕРЕБРАТЬ ВСЕ ЗНАЧЕНИЯ MAP, УЧИТЫВАЯ, ЧТО MAP - ЭТО НЕ ITERABLE?**

Ответ: Использовать метод values(), который возвращает коллекцию (Collection<V>) значений.

**15. КАК ПЕРЕБРАТЬ ВСЕ ПАРЫ КЛЮЧ-ЗНАЧЕНИЕ В MAP, УЧИТЫВАЯ, ЧТО MAP - ЭТО НЕ ITERABLE?**

Ответ: Использовать метод entrySet(), который возвращает множество (Set<Map.Entry><K,V>) пар ключ-значение.

**16. В ЧЕМ ПРОЯВЛЯЕТ СОРТИРОВАННОСТЬ SORTEDMAP?**

Ответ: Интерфейс SortedMap расширяет Map и создает отображение, в котором все элементы отсортированы в порядке возрастания их ключей.

**17. КАКИМ ОДНИМ ВЫЗОВОМ КОПИРОВАТЬ ЭЛЕМЕНТЫ ИЗ ЛЮБОЙ COLLECTION В МАССИВ?**

Ответ:

![](https://1.bp.blogspot.com/-D1Swg0zDSYw/VpIDH0shNdI/AAAAAAAAAHw/d2-5Jm7xh_Q/s640/collection_to_array.jpg)

**18. РЕАЛИЗУЙТЕ СИММЕТРИЧЕСКУЮ РАЗНОСТЬ ДВУХ КОЛЛЕКЦИЙ, ИСПОЛЬЗУЯ МЕТОДЫ COLLECTION (ADDALL(),REMOVEALL(),RETAINALL())?**

Ответ:Симметрическая разность двух коллекций - это множество элементов, одновременно не принадлежащих обоим исходным коллекциям.

![](https://1.bp.blogspot.com/-tO8NHPp0eC8/VpIDezzKqaI/AAAAAAAAAH4/4HeaQHAMWuM/s640/symmetric_difference_collection.jpg)

**19. СРАВНИТЕ ENUMERATION И ITERATOR?**

Ответ: Оба интерфейса предназначены для обхода коллекций. Интерфейс Iterator был введен несколько позднее в JCF. Основные различия:
 
 * наличие метода remove() для удаления элемента при обходе
 * исправлены имена методов для повышения читаемости кода

**20. КАК МЕЖДУ СОБОЙ СВЯЗАНЫ ITERABLE И ITERATOR?**

Ответ: Интерфейс Iterable имеет только один метод iterator(), который возвращает итератор коллекции для её обхода.

**21. СРАВНИТЕ ITERATOR И LISTITERATOR?**

Ответ: ListIterator расширяет интерфейс  Iterator, позволяя клиенту осуществлять обход коллекции в обоих направлениях, изменять коллекцию и получать текущую позицию итератора.

При этом важно помнить, что ListIterator не указывает на конкретный элемент, а его текущая позиция располагется между элементами, которые возвращают методы previous() и next(). Т.об., модификация коллекции осуществляется для последнего элемента, который был возвращен мтодами previous() и next().

**22. ЧТО ПРОИЗОЙДЕТ, ЕСЛИ Я ВЫЗОВУ ITERATOR.NEXT() НЕ СПРОСИВ ITERATOR.HASNEXT()?**

Ответ: Если итератор указывает на последний элемент коллекции, то возникнет исключение NoSuchElementException, иначе будет возращен следующий элемент.

**23. ЕСЛИ У МЕНЯ ЕСТЬ КОЛЛЕКЦИЯ И ПОРОЖДЕННЫЙ ИТЕРАТОР, ИЗМЕНИТСЯ ЛИ КОЛЛЕКЦИЯ, ЕСЛИ Я ВЫЗОВУ ITERATOR.REMOVE()?**

Ответ: Вызов метода Iterator.remove() возможен только после вызова метода iterator.next(), хотя бы раз, иначе появится исключение IllegalStateException(). Если Iterator.next() был вызван прежде, то iterator.remove() удалит элемент, но который указывает итератор.

**24. ЕСЛИ У МЕНЯ ЕСТЬ КОЛЛЕКЦИЯ И ПОРОЖДЕННЫЙ ИТЕРАТОР, ИЗМЕНИТСЯ ЛИ ИТЕРАТОР, ЕСЛИ Я ВЫЗОВУ COLLECTION.REMOVE()?**

Ответ: Итератор не изменится, но при следующем вызове его методов возникнет исключение ConcurrentModificationException.

**25. В РЕАЛИЗАЦИИ КЛАССА ARRAYLIST ЕСТЬ СЛЕДУЮЩИЕ ПОЛЯ: OBJECT(), ELEMENTDATA, INT SIZE. ЗАЧЕМ ХРАНИТЬ ОТДЕЛЬНО SIZE, ЕСЛИ ВСЕГДА МОЖНО ВЗЯТЬ ELEMENTDATA.LENGHT?**

Ответ: Размер массива elementData представляет собой вместимость(capacity) ArrayList, которая всегда больше переменной size - реального количества хранимых элементов. С добавлением новых элементов вместимость автоматически возрастает при необходимости.


