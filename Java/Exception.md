**1. Опишите иерархию исключений**

Ответ:
![](https://s3.amazonaws.com/geekbrains-uploads/geekbrains/public/ckeditor_assets/pictures/4232/content_pasted_image_0.png)

Все классы-исключения расширяют класс Throwable. У класса Throwable и у всех его расширений по умолчанию 2 конструктора: 

* Throwable o - конструктор по умолчанию
* Throwable(String message) - создаваемый объект будет содержать сообщение. Записанное в конструкторе сообщение можно потом получить методом getMessage().

Методы, которые выводят сообщения обо всех методах, встретившихся по пути "полета" исключения:

* printStackTrace() - выводит сообщения в стандартный вывод(консоль)
* printStackTrace(PrintStream stream) - выводит сообщение в байтовый поток stream
* printStackTrace(PrintWriter stream) - выводит сообщение в символьный поток stream

У класса Throwable два наследника: Error и Exception. Они не добавляют новых методов, а служат для разделения классов-семейств - классов-ошибок и классов-исключений.

Классы расширяющие класс Error, свидетельствуют  о возникновении сложных ситуаций в виртуальной машине Java.

Классы расширяющие класс Exception, отмечают возникновение ситуации, которую можно и даже нужно обрабатывать. Такие исключения следует выбросить оператором throw. Классов-исключений довольно много(около 200).

RuntimeException - отмечают исключения, возникшие при работе JVM, но не такие серьезные как ошибки. Их можно обрабатывать и выбрасывать, чаще всего  это просто ошибка в программе, которую нужно исправить. Особенность этих исключений, что их не нужно отмечать в загаловке метода пометкой throws.

**2. Что такое checked и unchecked exception?**

Ответ: Checked исключение - это исключения, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked исключения могут не обрабатываться  и не быть описанными. 

Пример unchecked - NullPointerException, checked - IOException.

Наличие\обработка Checked исключения проверяются на этапе компиляции. Наличие\обработка Unchecked исключения происходит на этапе выполнения.

**3. Как создать свой  uncheсked exception?**

Ответ: Унаследоваться от RuntimeException.

**4. Какие есть unchecked exception?**

Ответ: 

![](https://2.bp.blogspot.com/-QlWwhPtfQ4E/V53E6Oyx4bI/AAAAAAAAA_w/VDXBUiPjDBwW39LaPJ6ZqL7fmzhHUPviACLcB/s640/q049_p01.jpg)

**5. Могли бы вы придумать ситуацию, когда блок finally не будет выполнен?**

Ответ: 
```java
try {
    System.exit(0);
} catch(Exception e){
    e.printStackTrace();
} finally{}
```

Здесь finally недостижим, так как происходит системный выход из программы. Общими словами: когда jvm умирает, ей не до finally.

Также существуют потоки-демоны - потоки, предостовляющие некие сервисы, работая в фоновом режиме во время выполнения программы, но при этом не являются ее неотъемлевой частью. Т.об. когда все потоки не-демоны завершаются, программа завершает свою работу. В потоках демонах блок finally не выполняется, они прерываются внезапно.

Если в блоке finally произошло исключение и нет обработчика, то оставшийся код в блоке finally может не выполняться.

**6. Если оператор return содержится и в блоке catch и в finally, какой из них “главнее”?**

Ответ: Вернется из блока finally.

**7.  Может ли не быть ни одного блока catch при отлавливании исключений?**

Ответ: Такая запись допустима, если имеется связка try{} finally {}. Но смысла в такой записи не так много, всё же лучше иметь блок catch в котором будет обрабатываться необходимое исключение.