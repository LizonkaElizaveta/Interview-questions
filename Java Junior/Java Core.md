1. Чем отличается JRE, JVM и JDK?

Ответ: *JRE(Java Runtime Environment) - минимальная реализация виртуальной машины, необходимая для исполнения приложений, без компилятора и других средств разработки. Состоит из виртуальной машины и библиотеки java-классов.* 

*JDK(Java Development Kit) - бесплатно распространяемый компанией Oracle Corporation комплект разработчика приложений на языке Java, включающий в себя компилятор(javac), стандартные библиотеки классов Java, примеры, документацию, различные утилиты и исполнительную систему JRE.*

*JVM(Java Virtual Machine) - виртуальная машина Java, основная часть исполняющей системы JRE. Виртуальная машина Java интерпретирует байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java(javac). JVM может также использоваться для выполнения программ, написанных на других языках программирования*.

2. Опишите модификаторы доступа в Java.

Ответ: *private - доступ разрешен только в текущем классе; default - доступ на уровне пакета; protected - доступ на уровне пакета и в иерархии наследования; public - доступен всем*.

3. Что такое package level access? 

Ответ: *Доступ из классов одного пакета в классы другого пакета*.

4. Чем абстрактный класс отличается от интерфейса? В каких случаях вы бы использовали абстрактный класс, а в каких интерфейс?

Ответ: *Абстрактный класс - это класс, который помечен как "abstract", он может(а может и нет) содержать абстрактные методы. Экземпляр абстрактного класса нельзя создать. Если класс наследуется от абстрактного класса - он тоже дб абстрактным.* 

*Интерфейс - абстрактный класс, у которого все методы public и abstract, а переменные public static final. Начиная с Java 8  в интерфейсах появились default methods(логика метода реализована по умолчанию). При реализации интерфейсов - класс обязан реализовать все методы интерфейса, иначе класс помечается как абстрактный. Интерфейсы мб использованы для передачи функции в другой метод, такие интерфейсы - функциональные.*

*Интерфейсы используются для организации множественного наследования. Абстрактый класс используется, когда  нам нужна какая-то реализация по умолчанию, интерфейс - когда классу нужно указать конкретное поведение. Часто абстрактный класс и интерфейс комбинируют, чтобы указать поведение и реализацию по умолчанию*.

5. Может ли объект получить доступ к private-переменной класса? Если да, то каким образом?

Ответ: *Доступ у приватной переменной класса можно получить только внутри класса, в котором она объявлена. Также доступ к переменной можно получить через Java Reflection API(это механизм исследования данных о программе во время её выполнения). Также с помощью него можно определить класс объекта, получить информацию о модификаторах доступа(полях, методах, конструкторах), создать экземпляр класса(имя которого неизвестно до момента выполнения программы), получить и установить значение свойства объекта. Для получения private : gettDeclaredField(), setAccessible(true), setInt(). final-переменные остаются неизменными*.

6. Для чего в Java статические блоки?

Ответ: *Статические блоки выполняются до выполнения конструктора, с помощью них инициализируются статические поля. Блок статической инициализации может создаваться сам при компиляции программы : public static int MAX = 10*.

7. Можно ли перегрузить static-метод?

Ответ: *Статические методы могут перегружаться нестатическими и наоборот - без ограничений. А вот переопределяться - нет.*.

8. Расскажите про внутренние классы, когда вы их будете использовать?

Ответ: *Внутренний класс - это класс, который находится внутри класса или интерфейса. ри этом он получает доступ ко всем полям и методам внешнего класса. Статический класс не содержит ссылки на внешний класс и имеет доступ только к статическим методам и переменным. Используется для того, чтобы обеспечить какую-то дополнительную логику класса*.

9. В чем разница между переменной экземпляра и статической переменной? 

Ответ: *Статические переменные инициализируются при загрузке класслодером, и не зависят от объекта (глобальная переменная для подсчета пользователей на сайте). Переменная экземпляра инициализируется при создании класса(каждый пользователь на сайте - объект)*.

10. Приведите пример кода, когда можно использовать статический метод?

Ответ: *Статические методы мб использованы для инициализации статических переменных. Часто статические методы используются в классах утилитах, таких как Collections, Math, Arrays*.

11. Расскажите про классы-загрузчики и про динамическую загрузку классов?

Ответ: *В Java существует три стандартных загрузчика, каждый из которых осуществляет загрузку класса из определенного места: Bootstrap – базовый загрузчик, также называется Primordial ClassLoader(загружает стандартные классы JDK из архива rt.jar); Extension ClassLoader – загрузчик расширений(загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext, но могут быть заданы системным свойством java.ext.dir);System ClassLoader – системный загрузчик (загружает классы приложения, определенные в переменной среды окружения CLASSPATH).*

*В Java используется иерархия загрузчиков классов, где корневым, разумеется, является базовый. Далее следует загрузчик расширений, а за ним уже системный. Естественно, каждый загрузчик хранит указатель на родительский для того, чтобы смочь делегировать ему загрузку в том случае, если сам будет не в состоянии этого сделать.*.

12. Для чего нужен оператор assert в Java?

Ответ: *Утверждения (с помощью ключевого слова assert) были добавлены в Java 1.4. Они используются для проверки правильности инварианта в коде. Они никогда не должны запускаться в производственном коде и указывают на ошибку или неправильное использование кода. Исключения Java - это аналогичная концепция, но они не могут проверить все. Если вы хотите еще больше проверок (за счет скорости выполнения), вам нужно использовать утверждения. Это приведет к раздуванию вашего кода, но в конечном итоге вы сможете доставить продукт на удивительно короткое время разработки (чем раньше вы исправляете ошибку, тем ниже стоимость). И кроме того: если в вашем коде есть какая-то ошибка, вы ее обнаружите*.
```java
void doSomething(Widget widget) {
  assert widget != null;
  widget.someMethod(); // ...
    ... // do more stuff with this widget
}
```

13. Почему в некоторых интерфейсах вообще не определяют методов?

Ответ: *Это интерфейсы маркеры. Они просто указывают, что класс относится к определенной группе классов. Интерфейсы-маркеры : Searilizable, Cloneable, Remote, ThreadSafe*.

14. Какая основная разница между String, StringBuffer, StringBuilder?

Ответ: *Класс String является immutable - Вы не можете модифицировать объект String, но можете заменить его созданием нового экземпляра. Создание нового экземпляра обходится дороговато. Класс StringBuffer является mutable - использовать StringBuffer или StringBuilder следует тогда, когда вы хотите модифицировать содержимое. StringBuilder был добавлен в пятой джаве и он во всем идентичен классу StringBuffer, за исключением того, что он не синхронизирован, что делает его значительно шустрее. Но цена скорости - небезопасное поведение в мультипоточной среде.*. 

15. Расскажите про потоки ввода/вывода в Java?

Ответ: *Потоком ввода/вывода (I/O Stream) называется произвольный источник или приемник, который способен генерировать либо получать некоторые данные. Данными выступают последовательности байт. Таким образом поток ввода/вывода – это последовательность байт. С точки зрения потоков ввода/вывода Java программа сможет работать с последовательностью байт с файла, сетевого соединения интернет сайта и т.д. без каких либо изменений в коде.*

*Для работы с двоичными (бинарными) данными в Java существуют два базовых абстрактных класса: InputStream и OutputStream; для работы с текстовыми данными в Java существуют два базовых абстрактных класса: Reader и Writer.* 

*При работе с потоками ввода/вывода обязательно использовать try-withresource конструкцию, иначе может быть утечка памяти и сбой в работе программы.* 

*java.io.File класс представляет АПИ для доступа к объекту файловой системы. Начиная с версии JDK 1.7 в Java   Path и Files для работы с объектами файловой системы. Properties файлы удобны для настроек системы*.

16. Что такое Heap и Stack память в Java?

Ответ: *Java Heap - динамически распределяемая область памяти, создаваемая при старте JVM. Все объекты обитают в куче и попадают туда при создании. Здесь работает сборщик мусора(освобождает память путем удаления объектов, на которые нет каких-либо ссылок). Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения*.

*Стековая память в Java работает по схеме LIFO (Последний-зашел-Первый-вышел). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче.*

17. Какая разница между Stack и Heap памятью в Java?

Ответ:  
* *Куча используется всеми частями приложения в то время как стек используется только одним потоком исполнения программы.*

* *Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.*

* *Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.*

* *Управление памятью в стеке осуществляется по схеме LIFO.*

* *Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.*

* *Мы можем использовать -Xms и -Xmx опции JVM, чтобы определить начальный и максимальный размер памяти в куче. Для стека определить размер памяти можно с помощью опции -Xss .*

* *Если память стека полностью занята, то Java Runtime бросает java.lang.StackOverflowError, а если память кучи заполнена, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.*

* *Размер памяти стека намного меньше памяти в куче. Из-за простоты распределения памяти (LIFO), стековая память работает намного быстрее кучи.*

18. Расскажите про модель памяти в Java?

Ответ: ![Java Memory Model](https://www.google.com/search?q=java+memory+model&newwindow=1&rlz=1C1GGRV_enBY753BY754&source=lnms&tbm=isch&sa=X&ved=0ahUKEwj45aHunPXhAhUDcZoKHVoPDTcQ_AUIDigB&biw=1366&bih=625#imgrc=XthMsleaYbQlRM:)

