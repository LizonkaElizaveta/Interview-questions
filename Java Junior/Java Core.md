1. Чем отличается JRE, JVM и JDK?

Ответ: *JRE(Java Runtime Environment) - минимальная реализация виртуальной машины, необходимая для исполнения приложений, без компилятора и других средств разработки. Состоит из виртуальной машины и библиотеки java-классов.* 

*JDK(Java Development Kit) - бесплатно распространяемый компанией Oracle Corporation комплект разработчика приложений на языке Java, включающий в себя компилятор(javac), стандартные библиотеки классов Java, примеры, документацию, различные утилиты и исполнительную систему JRE.*

*JVM(Java Virtual Machine) - виртуальная машина Java, основная часть исполняющей системы JRE. Виртуальная машина Java интерпретирует байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java(javac). JVM может также использоваться для выполнения программ, написанных на других языках программирования*.

2. Опишите модификаторы доступа в Java.

Ответ: *private - доступ разрешен только в текущем классе; default - доступ на уровне пакета; protected - доступ на уровне пакета и в иерархии наследования; public - доступен всем*.

3. Что такое package level access? 

Ответ: *Доступ из классов одного пакета в классы другого пакета*.

4. Чем абстрактный класс отличается от интерфейса? В каких случаях вы бы использовали абстрактный класс, а в каких интерфейс?

Ответ: *Абстрактный класс - это класс, который помечен как "abstract", он может(а может и нет) содержать абстрактные методы. Экземпляр абстрактного класса нельзя создать. Если класс наследуется от абстрактного класса - он тоже дб абстрактным.* 

*Интерфейс - абстрактный класс, у которого все методы public и abstract, а переменные public static final. Начиная с Java 8  в интерфейсах появились default methods(логика метода реализована по умолчанию). При реализации интерфейсов - класс обязан реализовать все методы интерфейса, иначе класс помечается как абстрактный. Интерфейсы мб использованы для передачи функции в другой метод, такие интерфейсы - функциональные.*

*Интерфейсы используются для организации множественного наследования. Абстрактый класс используется, когда  нам нужна какая-то реализация по умолчанию, интерфейс - когда классу нужно указать конкретное поведение. Часто абстрактный класс и интерфейс комбинируют, чтобы указать поведение и реализацию по умолчанию*.

5. Может ли объект получить доступ к private-переменной класса? Если да, то каким образом?

Ответ: *Доступ у приватной переменной класса можно получить только внутри класса, в котором она объявлена. Также доступ к переменной можно получить через Java Reflection API(это механизм исследования данных о программе во время её выполнения). Также с помощью него можно определить класс объекта, получить информацию о модификаторах доступа(полях, методах, конструкторах), создать экземпляр класса(имя которого неизвестно до момента выполнения программы), получить и установить значение свойства объекта. Для получения private : gettDeclaredField(), setAccessible(true), setInt(). final-переменные остаются неизменными*.

6. Для чего в Java статические блоки?

Ответ: *Статические блоки выполняются до выполнения конструктора, с помощью них инициализируются статические поля. Блок статической инициализации может создаваться сам при компиляции программы : public static int MAX = 10*.

7. Можно ли перегрузить static-метод?

Ответ: *Статические методы могут перегружаться нестатическими и наоборот - без ограничений. А вот переопределяться - нет.*.

8. Расскажите про внутренние классы, когда вы их будете использовать?

Ответ: *Внутренний класс - это класс, который находится внутри класса или интерфейса. ри этом он получает доступ ко всем полям и методам внешнего класса. Статический класс не содержит ссылки на внешний класс и имеет доступ только к статическим методам и переменным. Используется для того, чтобы обеспечить какую-то дополнительную логику класса*.

9. В чем разница между переменной экземпляра и статической переменной? 

Ответ: *Статические переменные инициализируются при загрузке класслодером, и не зависят от объекта (глобальная переменная для подсчета пользователей на сайте). Переменная экземпляра инициализируется при создании класса(каждый пользователь на сайте - объект)*.

10. Приведите пример кода, когда можно использовать статический метод?

Ответ: *Статические методы мб использованы для инициализации статических переменных. Часто статические методы используются в классах утилитах, таких как Collections, Math, Arrays*.

11. Расскажите про классы-загрузчики и про динамическую загрузку классов?

Ответ: *В Java существует три стандартных загрузчика, каждый из которых осуществляет загрузку класса из определенного места: Bootstrap – базовый загрузчик, также называется Primordial ClassLoader(загружает стандартные классы JDK из архива rt.jar); Extension ClassLoader – загрузчик расширений(загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext, но могут быть заданы системным свойством java.ext.dir);System ClassLoader – системный загрузчик (загружает классы приложения, определенные в переменной среды окружения CLASSPATH).*

*В Java используется иерархия загрузчиков классов, где корневым, разумеется, является базовый. Далее следует загрузчик расширений, а за ним уже системный. Естественно, каждый загрузчик хранит указатель на родительский для того, чтобы смочь делегировать ему загрузку в том случае, если сам будет не в состоянии этого сделать.*.

12. Для чего нужен оператор assert в Java?

Ответ: *Утверждения (с помощью ключевого слова assert) были добавлены в Java 1.4. Они используются для проверки правильности инварианта в коде. Они никогда не должны запускаться в производственном коде и указывают на ошибку или неправильное использование кода. Исключения Java - это аналогичная концепция, но они не могут проверить все. Если вы хотите еще больше проверок (за счет скорости выполнения), вам нужно использовать утверждения. Это приведет к раздуванию вашего кода, но в конечном итоге вы сможете доставить продукт на удивительно короткое время разработки (чем раньше вы исправляете ошибку, тем ниже стоимость). И кроме того: если в вашем коде есть какая-то ошибка, вы ее обнаружите*.
```java
void doSomething(Widget widget) {
  assert widget != null;
  widget.someMethod(); // ...
    ... // do more stuff with this widget
}
```

13. Почему в некоторых интерфейсах вообще не определяют методов?

Ответ: *Это интерфейсы маркеры. Они просто указывают, что класс относится к определенной группе классов. Интерфейсы-маркеры : Searilizable, Cloneable, Remote, ThreadSafe*.

14. Какая основная разница между String, StringBuffer, StringBuilder?

Ответ: *Класс String является immutable - Вы не можете модифицировать объект String, но можете заменить его созданием нового экземпляра. Создание нового экземпляра обходится дороговато. Класс StringBuffer является mutable - использовать StringBuffer или StringBuilder следует тогда, когда вы хотите модифицировать содержимое. StringBuilder был добавлен в пятой джаве и он во всем идентичен классу StringBuffer, за исключением того, что он не синхронизирован, что делает его значительно шустрее. Но цена скорости - небезопасное поведение в мультипоточной среде.*. 

15. Расскажите про потоки ввода/вывода в Java?

Ответ: *Потоком ввода/вывода (I/O Stream) называется произвольный источник или приемник, который способен генерировать либо получать некоторые данные. Данными выступают последовательности байт. Таким образом поток ввода/вывода – это последовательность байт. С точки зрения потоков ввода/вывода Java программа сможет работать с последовательностью байт с файла, сетевого соединения интернет сайта и т.д. без каких либо изменений в коде.*

*Для работы с двоичными (бинарными) данными в Java существуют два базовых абстрактных класса: InputStream и OutputStream; для работы с текстовыми данными в Java существуют два базовых абстрактных класса: Reader и Writer.* 

*При работе с потоками ввода/вывода обязательно использовать try-withresource конструкцию, иначе может быть утечка памяти и сбой в работе программы.* 

*java.io.File класс представляет АПИ для доступа к объекту файловой системы. Начиная с версии JDK 1.7 в Java   Path и Files для работы с объектами файловой системы. Properties файлы удобны для настроек системы*.

16. Что такое Heap и Stack память в Java?

Ответ: *Java Heap - динамически распределяемая область памяти, создаваемая при старте JVM. Все объекты обитают в куче и попадают туда при создании. Здесь работает сборщик мусора(освобождает память путем удаления объектов, на которые нет каких-либо ссылок). Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения*.

*Стековая память в Java работает по схеме LIFO (Последний-зашел-Первый-вышел). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче.*

17. Какая разница между Stack и Heap памятью в Java?

Ответ:  
* *Куча используется всеми частями приложения в то время как стек используется только одним потоком исполнения программы.*

* *Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.*

* *Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.*

* *Управление памятью в стеке осуществляется по схеме LIFO.*

* *Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.*

* *Мы можем использовать -Xms и -Xmx опции JVM, чтобы определить начальный и максимальный размер памяти в куче. Для стека определить размер памяти можно с помощью опции -Xss .*

* *Если память стека полностью занята, то Java Runtime бросает java.lang.StackOverflowError, а если память кучи заполнена, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.*

* *Размер памяти стека намного меньше памяти в куче. Из-за простоты распределения памяти (LIFO), стековая память работает намного быстрее кучи.*

18. Расскажите про модель памяти в Java?

Ответ: *В Java память устроена следующим образом, есть 2 вида: куча и стек*

![Java Memory Model](https://cdn-images-1.medium.com/max/800/1*YhrLZsWIzmSyH-6FYlndAA.png)

19.  Как работает уборщик мусора?

Ответ: *Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора.*

***Serial(последовательный) GC** - самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.*

*При использовании данного сборщика куча разбивается на четыре региона, три из которых относятся к младшему поколению (Eden, Survivor 0 и Survivor 1), а один (Tenured) — к старшему:*

![](https://hsto.org/files/6b0/3a9/e6d/6b03a9e6d8174da3a7b228eb9acbe001.png)

*Среднестатистический объект начинает свою жизнь в регионе Eden (объекты-акселераты, размер которых настолько велик, что создавать их в Eden, а потом таскать за собой по Survivor’ам слишком накладно. В этом случае они размещаются сразу в Tenured.). Именно сюда его помещает JVM в момент создания. Но со временем может оказаться так, что места для вновь создаваемого объекта в Eden нет, в таких случаях запускается малая сборка мусора.*

*Первым делом такая сборка находит и удаляет мертвые объекты из Eden. Оставшиеся живые объекты переносятся в пустой регион Survivor. JVM постоянно следит за тем, как долго объекты перемещаются между Survivor 0 и Survivor 1, и выбирает подходящий порог для количества таких перемещений, после которого объекты перемещаются в Tenured, то есть переходят в старшее поколение. Если регион Survivor оказывается заполненным, то объекты из него также отправляются в Tenured.*

![](https://hsto.org/files/20b/a5e/2fa/20ba5e2faa614c558593413268b729c2.png)

*Из двух основных способов работы с выжившими объектами — уплотнение и копирование — в Sun при разработке малого сборщика мусора пошли по второму пути, так как он проще в реализации и зачастую оказывается производительнее.старшее поколение не делится на подрегионы по аналогии с младшим, а представляет собой один большой кусок памяти, поэтому после удаления мертвых объектов из Tenured производится не перенос данных (переносить уже некуда), а их уплотнение, то есть размещение последовательно, без фрагментации.*

***Parallel (параллельный) GC** — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности(используется чаще всего).*

*При подключении параллельного сборщика используются те же самые подходы к организации кучи, что и в случае с Serial GC — она делится на такие же регионы Eden, Survivor 0, Survivor 1 и Old Gen (знакомый нам под именем Tenured), функционирующие по тому же принципу. Но есть два принципиальных отличия в работе с этими регионами: во-первых, сборкой мусора занимаются несколько потоков параллельно; во-вторых, данный сборщик может самостоятельно подстраиваться под требуемые параметры производительности.*

*Определяется общее количество потоков, которое равно количеству ядер, если ядер <= 8(если >, то домнажение на определенный коэффициент).Каждый поток сборщика получает свой участок памяти в регионе Old Gen, так называемый буфер повышения (promotion buffer), куда только он может переносить данные, чтобы не мешать другим потокам. Такой подход ускоряет сборку мусора, но имеет и небольшое негативное последствие в виде возможной фрагментации памяти.*

![](https://hsto.org/files/bed/e1a/c4c/bede1ac4c5c84aa9a3363a446b1be0b6.png)

*Интеллектуальная составляющая улучшений параллельного сборщика относительно последовательного заключается в том, что у него есть настройки, ориентированные на достижение необходимой вам эффективности сборки мусора. Вы можете указать устраивающие вас параметры производительности — максимальное время сборки и/или пропускную способность — и сборщик будет изо всех сил стараться не превышать заданные пороги. Для этого он будет использовать статистику уже прошедших сборок мусора и исходя из нее планировать параметры дальнейших сборок: варьировать размеры поколений, менять пропорции регионов.*

***Concurrent Mark Sweep (CMS)** — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти.*

*CMS GC использует ту же самую организацию памяти, что и уже рассмотренные Serial / Parallel GC: регионы Eden + Survivor 0 + Survivor 1 + Tenured и такие же принципы малой сборки мусора. Отличия начинаются только тогда, когда дело доходит до полной сборки. В случае CMS ее называют старшей (major) сборкой, а не полной, так как она не затрагивает объекты младшего поколения. В результате, малая и старшая сборки здесь всегда разделены.*

*Важным отличием сборщика CMS от рассмотренных ранее является также то, что он не дожидается заполнения Tenured для того, чтобы начать старшую сборку. Вместо этого он трудится в фоновом режиме постоянно, пытаясь поддерживать Tenured в компактном состоянии.*

*Старшая сборка начинается с остановки основных потоков приложения и пометки всех объектов, напрямую доступных из корней. После этого приложение возобновляет свою работу, а сборщик параллельно с ним производит поиск всех живых объектов, доступных по ссылкам из тех самых помеченных корневых объектов. После сборщик еще раз приостанавливает работу приложения и просматривает кучу для поиска живых объектов, ускользнувших от него за время первого прохода. После того, как живые объекты помечены, работа основных потоков приложения возобновляется, а сборщик производит очистку памяти от мертвых объектов в нескольких параллельных потоках. При этом следует иметь в виду, что после очистки не производится упаковка объектов в старшем поколении, так как делать это при работающем приложении весьма затруднительно.*

![](https://hsto.org/files/f9f/d54/9a2/f9fd549a2a104f1eb7acf5098dd0afe8.png)

*Отдельно следует рассмотреть ситуацию, когда сборщик не успевает очистить Tenured до того момента, как память полностью заканчивается. В этом случае работа приложения останавливается, и вся сборка производится в последовательном режиме.*

***Garbage-First (G1)** — создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных*

*Куча разделяется на набор областей кучи одинакового размера, каждый из которых представляет собой непрерывный диапазон виртуальной памяти. Регионы одного поколения не обязаны идти подряд и даже могут менять свою принадлежность к тому или иному поколению.*

![](https://hsto.org/files/34d/781/181/34d781181f5e4481be98557899ae0cf2.png)

*Малые сборки выполняются периодически для очистки младшего поколения и переноса объектов в регионы Survivor, либо их повышения до старшего поколения с переносом в Tenured. Над переносом объектов трудятся несколько потоков, и на время этого процесса работа основного приложения останавливается. Это уже знакомый нам подход из рассмотренных ранее сборщиков, но отличие состоит в том, что очистка выполняется не на всем поколении, а только на части регионов, которые сборщик сможет очистить не превышая желаемого времени. При этом он выбирает для очистки те регионы, в которых, по его мнению, скопилось наибольшее количество мусора и очистка которых принесет наибольший результат. Отсюда как раз название Garbage First — мусор в первую очередь.*

*После окончания малой сборки и пометки мусора, G1 переключается на выполнение смешанных сборок. Это значит, что при каждой сборке к набору регионов младшего поколения, подлежащих очистке, добавляется некоторое количество регионов старшего поколения. Количество таких сборок и количество очищаемых регионов старшего поколения выбирается исходя из имеющейся у сборщика статистики о предыдущих сборках таким образом, чтобы не выходить за требуемое время сборки. Как только сборщик очистил достаточно памяти, он переключается обратно в режим малых сборок.*

![](https://hsto.org/files/8ee/d12/62d/8eed1262d47a407a9f64f2df8635bdb6.png)

*Может оказаться так, что в процессе очистки памяти в куче не остается свободных регионов, в которые можно было бы копировать выжившие объекты. В таком случае сборщик выполняет полную сборку мусора по всей куче при остановленных основных потоках приложения.*

20. Расскажите про приведение типов. Что такое понижение и повышение типа? Когда вы получаете ClassCastException?

Ответ: *Приведение типов - это установка типа переменной или объекта отличного от текущего.*

![](https://vertex-academy.com/tutorials/wp-content/uploads/2016/11/%D0%9F%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-Java_Vertex-Academy.png)

*Автоматическое преобразование выглядит следующим образом:*

![](https://vertex-academy.com/tutorials/wp-content/uploads/2016/09/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-Java_Vertex-Academy.png)

*Если мы расширяем тип, то явное преобразование не требуется, приведение происходит автоматически. Если же мы сужаем, то необходимо явно указывать приведение типа.*

*В случае с объектами, то мы можем сделать автоматическое приведение от наследника к родителю, но никак наоборот, тогда вылетит ClassCastException.*

21. Что такое статический класс? Какие особенности его использования?

Ответ: **

22. Каким образом из вложенного класса получить доступ к полю внешнего класса?

Ответ: **

23. Какие существуют типы вложенных классов? Для чего они используются?

Ответ: **








