**1. Чем отличается JRE, JVM и JDK?**

Ответ: JRE(Java Runtime Environment) - минимальная реализация виртуальной машины, необходимая для исполнения приложений, без компилятора и других средств разработки. Состоит из виртуальной машины и библиотеки java-классов. 

JDK(Java Development Kit) - бесплатно распространяемый компанией Oracle Corporation комплект разработчика приложений на языке Java, включающий в себя компилятор(javac), стандартные библиотеки классов Java, примеры, документацию, различные утилиты и исполнительную систему JRE.

JVM(Java Virtual Machine) - виртуальная машина Java, основная часть исполняющей системы JRE. Виртуальная машина Java интерпретирует байт-код Java, предварительно созданный из исходного текста Java-программы компилятором Java(javac). JVM может также использоваться для выполнения программ, написанных на других языках программирования.

**2. Опишите модификаторы доступа в Java.**

Ответ: private - доступ разрешен только в текущем классе; default - доступ на уровне пакета; protected - доступ на уровне пакета и в иерархии наследования; public - доступен всем.

**3. Что такое package level access?**

Ответ: Доступ из классов одного пакета в классы другого пакета.

**4. Чем абстрактный класс отличается от интерфейса? В каких случаях вы бы использовали абстрактный класс, а в каких интерфейс?**

Ответ: Абстрактный класс - это класс, который помечен как "abstract", он может(а может и нет) содержать абстрактные методы. Экземпляр абстрактного класса нельзя создать. Если класс наследуется от абстрактного класса - он тоже дб абстрактным. 

Интерфейс - абстрактный класс, у которого все методы public и abstract, а переменные public static final. Начиная с Java 8  в интерфейсах появились default methods(логика метода реализована по умолчанию). При реализации интерфейсов - класс обязан реализовать все методы интерфейса, иначе класс помечается как абстрактный. Интерфейсы мб использованы для передачи функции в другой метод, такие интерфейсы - функциональные.

Интерфейсы используются для организации множественного наследования. Абстрактый класс используется, когда  нам нужна какая-то реализация по умолчанию, интерфейс - когда классу нужно указать конкретное поведение. Часто абстрактный класс и интерфейс комбинируют, чтобы указать поведение и реализацию по умолчанию.

**5. Может ли объект получить доступ к private-переменной класса? Если да, то каким образом?**

Ответ: Доступ у приватной переменной класса можно получить только внутри класса, в котором она объявлена. Также доступ к переменной можно получить через Java Reflection API(это механизм исследования данных о программе во время её выполнения). Также с помощью него можно определить класс объекта, получить информацию о модификаторах доступа(полях, методах, конструкторах), создать экземпляр класса(имя которого неизвестно до момента выполнения программы), получить и установить значение свойства объекта. Для получения private : gettDeclaredField(), setAccessible(true), setInt(). final-переменные остаются неизменными.

**6. Для чего в Java статические блоки?**

Ответ: Статические блоки выполняются до выполнения конструктора, с помощью них инициализируются статические поля. Блок статической инициализации может создаваться сам при компиляции программы : public static int MAX = 10.

**7. Можно ли перегрузить static-метод?**

Ответ: Статические методы могут перегружаться нестатическими и наоборот - без ограничений. А вот переопределяться - нет.

**8. Расскажите про внутренние классы, когда вы их будете использовать?**

Ответ: Внутренний класс - это класс, который находится внутри класса или интерфейса. ри этом он получает доступ ко всем полям и методам внешнего класса. Статический класс не содержит ссылки на внешний класс и имеет доступ только к статическим методам и переменным. Используется для того, чтобы обеспечить какую-то дополнительную логику класса.

**9. В чем разница между переменной экземпляра и статической переменной?**

Ответ: Статические переменные инициализируются при загрузке класслодером, и не зависят от объекта (глобальная переменная для подсчета пользователей на сайте). Переменная экземпляра инициализируется при создании класса(каждый пользователь на сайте - объект).

**10. Приведите пример кода, когда можно использовать статический метод?**

Ответ: Статические методы мб использованы для инициализации статических переменных. Часто статические методы используются в классах утилитах, таких как Collections, Math, Arrays.

**11. Расскажите про классы-загрузчики и про динамическую загрузку классов?**

Ответ: В Java существует три стандартных загрузчика, каждый из которых осуществляет загрузку класса из определенного места: Bootstrap – базовый загрузчик, также называется Primordial ClassLoader(загружает стандартные классы JDK из архива rt.jar); Extension ClassLoader – загрузчик расширений(загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext, но могут быть заданы системным свойством java.ext.dir);System ClassLoader – системный загрузчик (загружает классы приложения, определенные в переменной среды окружения CLASSPATH).

В Java используется иерархия загрузчиков классов, где корневым, разумеется, является базовый. Далее следует загрузчик расширений, а за ним уже системный. Естественно, каждый загрузчик хранит указатель на родительский для того, чтобы смочь делегировать ему загрузку в том случае, если сам будет не в состоянии этого сделать.

**12. Для чего нужен оператор assert в Java?**

Ответ: Утверждения (с помощью ключевого слова assert) были добавлены в Java 1.4. Они используются для проверки правильности инварианта в коде. Они никогда не должны запускаться в производственном коде и указывают на ошибку или неправильное использование кода. Исключения Java - это аналогичная концепция, но они не могут проверить все. Если вы хотите еще больше проверок (за счет скорости выполнения), вам нужно использовать утверждения. Это приведет к раздуванию вашего кода, но в конечном итоге вы сможете доставить продукт на удивительно короткое время разработки (чем раньше вы исправляете ошибку, тем ниже стоимость). И кроме того: если в вашем коде есть какая-то ошибка, вы ее обнаружите.
```java
void doSomething(Widget widget) {
  assert widget != null;
  widget.someMethod(); // ...
    ... // do more stuff with this widget
}
```

**13. Почему в некоторых интерфейсах вообще не определяют методов?**

Ответ: Это интерфейсы маркеры. Они просто указывают, что класс относится к определенной группе классов. Интерфейсы-маркеры : Searilizable, Cloneable, Remote, ThreadSafe.

**14. Какая основная разница между String, StringBuffer, StringBuilder?**

Ответ: Класс String является immutable - Вы не можете модифицировать объект String, но можете заменить его созданием нового экземпляра. Создание нового экземпляра обходится дороговато. Класс StringBuffer является mutable - использовать StringBuffer или StringBuilder следует тогда, когда вы хотите модифицировать содержимое. StringBuilder был добавлен в пятой джаве и он во всем идентичен классу StringBuffer, за исключением того, что он не синхронизирован, что делает его значительно шустрее. Но цена скорости - небезопасное поведение в мультипоточной среде. 

**15. Расскажите про потоки ввода/вывода в Java?**

Ответ: Потоком ввода/вывода (I/O Stream) называется произвольный источник или приемник, который способен генерировать либо получать некоторые данные. Данными выступают последовательности байт. Таким образом поток ввода/вывода – это последовательность байт. С точки зрения потоков ввода/вывода Java программа сможет работать с последовательностью байт с файла, сетевого соединения интернет сайта и т.д. без каких либо изменений в коде.

Для работы с двоичными (бинарными) данными в Java существуют два базовых абстрактных класса: InputStream и OutputStream; для работы с текстовыми данными в Java существуют два базовых абстрактных класса: Reader и Writer. 

При работе с потоками ввода/вывода обязательно использовать try-withresource конструкцию, иначе может быть утечка памяти и сбой в работе программы. 

java.io.File класс представляет АПИ для доступа к объекту файловой системы. Начиная с версии JDK 1.7 в Java   Path и Files для работы с объектами файловой системы. Properties файлы удобны для настроек системы.

**16. Что такое Heap и Stack память в Java?**

Ответ: Java Heap - динамически распределяемая область памяти, создаваемая при старте JVM. Все объекты обитают в куче и попадают туда при создании. Здесь работает сборщик мусора(освобождает память путем удаления объектов, на которые нет каких-либо ссылок). Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения.

Стековая память в Java работает по схеме LIFO (Последний-зашел-Первый-вышел). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче.

**17. Какая разница между Stack и Heap памятью в Java?**

Ответ:  
* Куча используется всеми частями приложения в то время как стек используется только одним потоком исполнения программы.

* Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.

* Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.

* Управление памятью в стеке осуществляется по схеме LIFO.

* Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.

* Мы можем использовать -Xms и -Xmx опции JVM, чтобы определить начальный и максимальный размер памяти в куче. Для стека определить размер памяти можно с помощью опции -Xss .

* Если память стека полностью занята, то Java Runtime бросает java.lang.StackOverflowError, а если память кучи заполнена, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.

* Размер памяти стека намного меньше памяти в куче. Из-за простоты распределения памяти (LIFO), стековая память работает намного быстрее кучи.

**18. Расскажите про модель памяти в Java?**

Ответ: В Java память устроена следующим образом:

![](https://www.yourkit.com/docs/kb/jvm_memory_structure.gif)

В куче хранятся все экземпляры классов и массивов. Куча создается при запуске JVM и может увеличиваться или уменьшаться в размере во время работы приложения. Куча может иметь фиксированный или переменный размер в зависимости от стратегии сбора мусора. По умолчанию размер кучи составляет 64 MB.

Память без кучи создается при запуске JVM и хранит структуры для каждого класса такие как: пул констант времени выполнения, данные полей и методов, а также код для методов и конструкторов и интернированные строки (хранение одной копии из множества одинаковых). По умолчанию размер памяти без кучи составляет 64 MB.

Other - JVM использует это пространство для хранения самого кода JVM, внутренних структур JVM, загруженного кода и данных агента профилировщика(сбор характеристик работы программы, таких как время выполнения отдельных фрагментов, число верно предсказанных условных переходов, число кэш-промахов и т. д.)

JVM куча физически делится на 2 части(поколения): молодое и старое.

В Eden Space выделяется память под все создаваемые из программы объекты. Большая часть объектов живет недолго у даляются при сборке мусора, и не перемещаются в другие области памяти. Когда данная область заполняется, GC выполняет быструю (minor collection) сборку мусора. По сравнению с полной сборкой мусора, она занимает мало времени,  и затрагивает только эту область памяти - очищает от устаревших объектов Eden Space и перемещает выжившие объекты в следующую область.

Survivor Space -  сюда перемещаются объекты из предыдущей части, после того как они пережили хотя бы одну сборку мусора. В одно время пространство для выживших всегда пусто. Объекты, которые пережилинесколько циклов GC, перемещаются в старое поколение.

Когда старое поколение становится заполненным, то вызывается полная сборка мусора, которая затрагивает больше времени.

Permanent Generatiom содержит метаданные приложения, требуемые JVM для описания классов и методов, используемых в приложении, а также библиотеки Java SE. Начиная с Java 8 вместо Perm Gen используется Metaspace, который не является частью кучи. Metaspace имеет возможность динамически расширятся, органиченная по умолчанию только размером нативной памяти.

![](https://i2.wp.com/betsol.com/wp-content/uploads/2017/06/java-memory-management-1.jpg?resize=1024%2C425&ssl=1)

![Java Memory Model](https://cdn-images-1.medium.com/max/800/1*YhrLZsWIzmSyH-6FYlndAA.png)

**19.   Как работает уборщик мусора?**

Ответ: Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора.

**Serial(последовательный) GC** - самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.

При использовании данного сборщика куча разбивается на четыре региона, три из которых относятся к младшему поколению (Eden, Survivor 0 и Survivor 1), а один (Tenured) — к старшему:

![](https://hsto.org/files/6b0/3a9/e6d/6b03a9e6d8174da3a7b228eb9acbe001.png)

Среднестатистический объект начинает свою жизнь в регионе Eden (объекты-акселераты, размер которых настолько велик, что создавать их в Eden, а потом таскать за собой по Survivor’ам слишком накладно. В этом случае они размещаются сразу в Tenured.). Именно сюда его помещает JVM в момент создания. Но со временем может оказаться так, что места для вновь создаваемого объекта в Eden нет, в таких случаях запускается малая сборка мусора.

Первым делом такая сборка находит и удаляет мертвые объекты из Eden. Оставшиеся живые объекты переносятся в пустой регион Survivor. JVM постоянно следит за тем, как долго объекты перемещаются между Survivor 0 и Survivor 1, и выбирает подходящий порог для количества таких перемещений, после которого объекты перемещаются в Tenured, то есть переходят в старшее поколение. Если регион Survivor оказывается заполненным, то объекты из него также отправляются в Tenured.

![](https://hsto.org/files/20b/a5e/2fa/20ba5e2faa614c558593413268b729c2.png)

Из двух основных способов работы с выжившими объектами — уплотнение и копирование — в Sun при разработке малого сборщика мусора пошли по второму пути, так как он проще в реализации и зачастую оказывается производительнее.старшее поколение не делится на подрегионы по аналогии с младшим, а представляет собой один большой кусок памяти, поэтому после удаления мертвых объектов из Tenured производится не перенос данных (переносить уже некуда), а их уплотнение, то есть размещение последовательно, без фрагментации.

**Parallel (параллельный) GC** — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности(используется чаще всего).

При подключении параллельного сборщика используются те же самые подходы к организации кучи, что и в случае с Serial GC — она делится на такие же регионы Eden, Survivor 0, Survivor 1 и Old Gen (знакомый нам под именем Tenured), функционирующие по тому же принципу. Но есть два принципиальных отличия в работе с этими регионами: во-первых, сборкой мусора занимаются несколько потоков параллельно; во-вторых, данный сборщик может самостоятельно подстраиваться под требуемые параметры производительности.

Определяется общее количество потоков, которое равно количеству ядер, если ядер <= 8(если >, то домнажение на определенный коэффициент).Каждый поток сборщика получает свой участок памяти в регионе Old Gen, так называемый буфер повышения (promotion buffer), куда только он может переносить данные, чтобы не мешать другим потокам. Такой подход ускоряет сборку мусора, но имеет и небольшое негативное последствие в виде возможной фрагментации памяти.

![](https://hsto.org/files/bed/e1a/c4c/bede1ac4c5c84aa9a3363a446b1be0b6.png)

Интеллектуальная составляющая улучшений параллельного сборщика относительно последовательного заключается в том, что у него есть настройки, ориентированные на достижение необходимой вам эффективности сборки мусора. Вы можете указать устраивающие вас параметры производительности — максимальное время сборки и/или пропускную способность — и сборщик будет изо всех сил стараться не превышать заданные пороги. Для этого он будет использовать статистику уже прошедших сборок мусора и исходя из нее планировать параметры дальнейших сборок: варьировать размеры поколений, менять пропорции регионов.

**Concurrent Mark Sweep (CMS)** — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти.

CMS GC использует ту же самую организацию памяти, что и уже рассмотренные Serial / Parallel GC: регионы Eden + Survivor 0 + Survivor 1 + Tenured и такие же принципы малой сборки мусора. Отличия начинаются только тогда, когда дело доходит до полной сборки. В случае CMS ее называют старшей (major) сборкой, а не полной, так как она не затрагивает объекты младшего поколения. В результате, малая и старшая сборки здесь всегда разделены.

Важным отличием сборщика CMS от рассмотренных ранее является также то, что он не дожидается заполнения Tenured для того, чтобы начать старшую сборку. Вместо этого он трудится в фоновом режиме постоянно, пытаясь поддерживать Tenured в компактном состоянии.

Старшая сборка начинается с остановки основных потоков приложения и пометки всех объектов, напрямую доступных из корней. После этого приложение возобновляет свою работу, а сборщик параллельно с ним производит поиск всех живых объектов, доступных по ссылкам из тех самых помеченных корневых объектов. После сборщик еще раз приостанавливает работу приложения и просматривает кучу для поиска живых объектов, ускользнувших от него за время первого прохода. После того, как живые объекты помечены, работа основных потоков приложения возобновляется, а сборщик производит очистку памяти от мертвых объектов в нескольких параллельных потоках. При этом следует иметь в виду, что после очистки не производится упаковка объектов в старшем поколении, так как делать это при работающем приложении весьма затруднительно.

![](https://hsto.org/files/f9f/d54/9a2/f9fd549a2a104f1eb7acf5098dd0afe8.png)

Отдельно следует рассмотреть ситуацию, когда сборщик не успевает очистить Tenured до того момента, как память полностью заканчивается. В этом случае работа приложения останавливается, и вся сборка производится в последовательном режиме.

**Garbage-First (G1)** — создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных

Куча разделяется на набор областей кучи одинакового размера, каждый из которых представляет собой непрерывный диапазон виртуальной памяти. Регионы одного поколения не обязаны идти подряд и даже могут менять свою принадлежность к тому или иному поколению.

![](https://hsto.org/files/34d/781/181/34d781181f5e4481be98557899ae0cf2.png)

Малые сборки выполняются периодически для очистки младшего поколения и переноса объектов в регионы Survivor, либо их повышения до старшего поколения с переносом в Tenured. Над переносом объектов трудятся несколько потоков, и на время этого процесса работа основного приложения останавливается. Это уже знакомый нам подход из рассмотренных ранее сборщиков, но отличие состоит в том, что очистка выполняется не на всем поколении, а только на части регионов, которые сборщик сможет очистить не превышая желаемого времени. При этом он выбирает для очистки те регионы, в которых, по его мнению, скопилось наибольшее количество мусора и очистка которых принесет наибольший результат. Отсюда как раз название Garbage First — мусор в первую очередь.

После окончания малой сборки и пометки мусора, G1 переключается на выполнение смешанных сборок. Это значит, что при каждой сборке к набору регионов младшего поколения,подлежащих очистке, добавляется некоторое количество регионов старшего поколения. Количество таких сборок и количество очищаемых регионов старшего поколения выбирается исходя из имеющейся у сборщика статистики о предыдущих сборках таким образом, чтобы не выходить за требуемое время сборки. Как только сборщик очистил достаточно памяти, он переключается обратно в режим малых сборок.

![](https://hsto.org/files/8ee/d12/62d/8eed1262d47a407a9f64f2df8635bdb6.png)

Может оказаться так, что в процессе очистки памяти в куче не остается свободных регионов, в которые можно было бы копировать выжившие объекты. В таком случае сборщик выполняет полную сборку мусора по всей куче при остановленных основных потоках приложения.

**20.  Расскажите про приведение типов. Что такое понижение и повышение типа? Когда вы получаете ClassCastException?**

Ответ: Приведение типов - это установка типа переменной или объекта отличного от текущего.

![](https://vertex-academy.com/tutorials/wp-content/uploads/2016/11/%D0%9F%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-Java_Vertex-Academy.png)

Автоматическое преобразование выглядит следующим образом:

![](https://vertex-academy.com/tutorials/wp-content/uploads/2016/09/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-Java_Vertex-Academy.png)

Если мы расширяем тип, то явное преобразование не требуется, приведение происходит автоматически. Если же мы сужаем, то необходимо явно указывать приведение типа.

В случае с объектами, то мы можем сделать автоматическое приведение от наследника к родителю, но никак наоборот, тогда вылетит ClassCastException.

**21. Что такое статический класс? Какие особенности его использования?**

Ответ: Статический класс м.б. только внутренний класс(определение класса размещается внутри другого класса). В объекте обычного внутреннего класса хранится ссылка на объект внешнего класса. Внутри статического внутреннего класса такой ссылки нет. Из объекта статического вложенного класса нельзя обращаться к нестатическим членам внешнего класса напрямую.

И еще обычные внутренние классы не могут содержать статические методы и члены. Каждый внутренний класс способен независимо наследовать определенную реализацию. Т.об. внутренний класс не ограничен при наследовании в ситуациях, когда внешний класс уже наследует реализацию(т.е. вариант решения проблемы множественного наследования).

**22. Каким образом из вложенного класса получить доступ к полю внешнего класса?**

Ответ: *ВнешнийКласс.this.поле, для статического внутреннего класса - создать объект внешнего класса, и вызвать get/set внешнего класса. Или объявить поле внешнего класса как static*

**23. Какие существуют типы вложенных классов? Для чего они используются?**

Ответ: Два типа вложенных классов: статические(вложенный) и нестатические(внутренние, анонимные).

Вложенный класс имеет доступ к членам своего внешнего класса, в том числе и к закрытым членам. Однако, внешний класс не имеет доступа к членам вложенного класса. Вложенный класс при этом является членом внешнего класса.

Внутренний класс имеет доступ ко всем переменным и методам своего внешнего класса и может непосредственно ссылаться на них.Если понадобится создать объект внутреннего класса не в статическом методе внешнего класса, тип этого объекта должен задаваться в формате ИмяВнешнегоКласса.ИмяВнутреннегоКласса.

Существует разновидность внутреннего класса, которая называется анонимным классом, так как у него нет имени. Подобные классы очень часто встречаются в примерах на Android.

**24. Возможно ли при переопределении метода изменить: 1 модификатор доступа, 2 возращаемый тип, 3 тип аргумента или количество, 4 имя аргументов, 5 изменить порядок, количество или вовсе убрать секцию throws?**

Ответ: 1 - возможно изменить модификатор доступа, только при переопределении модификатора разрешается только расширить видимость метода(package -> protected -> public).

2 - возможно изменить возращаемый тип, только если выполняется понижающее преобразование(Downcasting), т.е. преобразование вниз по иерархии(Object -> Number -> Integer).

3 - нельзя изменить тип аргумента или количество, т.к. в таком случае происходит перегрузка(overload).

4 - можно изменять имя аргументов.

5 - возможно изменить порядок. Можно вовсе убрать секцию throws в методе, так как она уже определена. Также возможно добавлять новые исключения, которые наследуются от объявленных или исключения времени исполнения.

**25. Что такое Autoboxing/Unboxing?**

Ответ: Autoboxing/Unboxing - автоматическое преобразование примитивных типов в объектные и наоборот. Наличие такой возможности сокращает код, поскольку исключает необходимость выполнения явных преобразований  типов в очевидных случаях.

* Расширение "побеждает" упаковку в ситуации, когда становится выбор между расширением и упаковкой, расширение предпочтительней.
* Расширение побеждает переменное количество аргументов в ситуации, когда становится выбор между расширением и переменным количеством аргументов, расширение предпочтительней.
* Упаковка побеждает переменное количество аргументов в ситуации, когда становится выбор между упаковкой и переменным количеством аргументов, упаковка предпочтительней.
* Смешивание объектов и примитивных типов с оператором равенства и отношения. Если мы сравниваем примитивный тип с объектом, то происходит распаковывание объекта, который может бросить NullPointerException если объект null.
* Кэширование объектов. Метод valueOf() создает контейнер примитивных объектов, которые он кэширует. Поскольку значения кэшируются в диапазоне от -128 до 127 включительно , эти кэшируемые объекты могут себя вести по-разному.
* Ухудшение производительности. Автоупаковка или распаковка ухудшают производительность приложения, поскольку это создает нежелательный объект, из-за которого сборщику мусора приходится работать чаще.

**26. Что такое Generics?**

Ответ: Generics(обобщения) - это параметризованные типы.С их помощью можно объявлять классы, интерфейсы и методы, где тип данных указан в виде параметра. Одно из назначений — более сильная проверка типов во время компиляции и устранение необходимости явного приведения. Параметризация доступна только на уровне компиляции.

**27. Какова истинная цель использования  обобщенных типов в Java?**

Ответ: Обобщенные типы в Java были изобретены, в первую очередь, для реализации обощенных коллекций.

**28. Каким образом передаются переменные в методы, по значению или по ссылке?**
Ответ: В Java параметры в методы передаются по значению, т.е. создаются копии параметров и с ними ведется работа в методе. В случае с примитивными типами, то при передаче  параметра сама переменная  не будет меняться, т.к. в метод прсто копируется ее значение.

При передаче объекта, копируется ссылка на объект, т.е. если в методе  мы поменяем состояние объекта, то и за методом состояние объекта тоже поменяется. Но если мы этой копиии ссылки попытаемся присвоить новую ссылку на объект, то старая ссылка  у нас не изменится.

Т.об объекты передаются по ссылке, а примитивы - по значению.

**29. Какие методы есть  у класса Object?**

Ответ: 
* public final native Class getClass() — возвращает в рантайме класс данного объекта.
* public native int hashCode() — возвращает хеш-код.
* public boolean eguals(Object obj) — сравнивает объекты.
* protected native Object clone() throws CloneNotSupportedException — клонирование объекта.
* public String toString() — возвращает строковое представление объекта.
* public final native void notify() — просыпается один поток, который ждет на “мониторе” данного объекта.
* public final native void notifyAll() — просыпаются все потоки, которые ждут на “мониторе” данного объекта.
* public final native void wait(long timeout) throws InterruptedException — поток переходит в режим ожидания в течение указанного времени.
* public final void wait(long timeout, int nanos) throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() для этого метода, или пока не истечет указанный промежуток времени.
* public final void wait() throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет notify() или notifyAll() методы для этого объекта.
* protected void finalize() throws Throwable — вызывается сборщиком мусора, когда garbage collector определил, что ссылок на объект больше нет.

**30. Правила переопределения метода Object.equals() и Object.hashCode()?**

Ответ: 

* Рефлексивность: Объект должен равняться себе самому.
* Симметричность: если a.equals(b) возвращает true, то b.equals(a) должен тоже вернуть true.
* Транзитивность: если a.equals(b) возвращает true и b.equals(c) тоже возвращает true, то c.equals(a) тоже должен возвращать true.
* Согласованность: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено. То есть, если два объекта равны в Java, то они будут равны пока их свойства остаются неизменными.
* Сравнение null: объект должны быть проверен на null. Если объект равен null, то метод должен вернуть false, а не NullPointerException. Например, a.equals(null) должен вернуть false.

**31. Какая связь между hashCode и equals?**

Ответ: Если объекты равны по результатам выполнения метода equals, тогда их hashcode должны быть одинаковыми.

Если объекты не равны по результатам выполнения метода equals, тогда их hashcode могут быть как одинаковыми, так и разными. Однако для повышения производительности, лучше, чтобы разные объекты возвращали разные коды.

**32. Как переопределять метод equals и hashCode?**

Ответ: 
``` java
public int id;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Main)) return false;
        Main main = (Main) o;
        return id == main.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
```

Общий алгоритм определения equals:
1. Проверить на равенство ссылки объектов this и параметра метода o.
```java 
if (this == o) return true; 
```
2. Проверить, определена ли ссылка o, т. е. является ли она null.
Если в дальнейшем при сравнении типов объектов будет использоваться оператор instanceof, этот пункт можно пропустить, т. к. этот параметр возвращает false в данном случае null instanceof Object.
3. Сравнить типы объектов this и o с помощью оператора instanceof или метода getClass().
4. Если метод equals переопределяется в подклассе, не забудьте сделать вызов super.equals(o)
5. Выполнить преобразование типа параметра o к требуемому классу.
6. Выполнить сравнение всех значимых полей объектов:
   * для примитивных типов (кроме float и double), используя оператор ==
   * для ссылочных полей необходимо вызвать их метод equals
   * для массивов можно воспользоваться перебором по циклу, либо методом Arrays.equals()
   * для типов float и double необходимо использовать методы сравнения соответствующих оберточных классов Float.compare() и Double.compare()
7. И, наконец, ответить на три вопроса: является ли реализованный метод симметричным? Транзитивным? Согласованным? Два других принципа (рефлексивность и определенность), как правило, выполняются автоматически.


**33. Каким образом реализованы методы hashCode и equals в классе Object?**

Ответ: Реализация метода equals в классе Object сводится к проверке на равенство 2 ссылок:
``` java
public boolean equals(Object obj) {
        return (this == obj);
    }
```
Реализация  метода hashCode в классе Object сделана нативной, т.е. определенной не с помощью Java-кода. Он обычно возращает адрес объекта в памяти:
``` java
 public native int hashCode();
```

**34. Что будет, если переопределить equals, не переопределяя hashCode? Какие могут возникнуть проблемы?**

Ответ: Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать. Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.

**35. Есть ли какие-либо рекомендации о том, какие поля  следует использовать при подсчете hashCode?**

Ответ: Необходимо использовать уникальные, лучше примитивные поля, такие как id, uuid. Причем если эти поля задейстованы при вычислении hashCode, то нужно их задействовать при вычислении equals.

**36. Для чего нужен метод hashCode?**

Ответ: У метода equals() есть большой минус – он слишком медленно работает. Для этого был придуман метод hashCode(). Для каждого объекта данный метод возвращает определенное число. Вместо того чтобы сравнивать объекты, будем сравнивать их hashCode, и только если hashCode-ы равны, сравнивать объекты посредством equals(). 

Дело в том, что коллекции в Java перед тем как сравнить объекты с помощью equals всегда ищут/сравнивают их с помощью метода hashCode(). И если у одинаковых объектов будут разные hashCode, то объекты будут считаться разными — до сравнения с помощью equals() просто не дойдет.

**37. Расскажите про клонирование объектов? В чем  отличие между поверхностным и глубоким клонированием?**

Ответ: Методо clone() позволяет создавать объект с аналогичной структурой, как и у исходного объекта. Чтобы объект можно было клонировать, он должен реализовывать интерфейс Cloneable(маркер).

Поверхностное копирование копирует настолько малую часть информации, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует. При клонировании, JVM делает такие вещи:   
* Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.
* Если класс содержит не только члены примитивных типов, а и любого другого типа класса, тогда копируются ссылки на объекты этих классов. Следовательно, оба объекта будут иметь одинаковые ссылки.

Для того, чтобы произвести глубокое клонирование, необъодимо в клонируемом классе переопределить метод clone().Глубокое копирование дублирует все. Глубокое копирование — это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции. Мы хотим сделать копию, при которой внесение изменений в любой элемент копии не затронет оригинальную коллекцию.

Глубокое клонирование требует выполнения следующих правил:
* Нет необходимости копировать отдельно примитивные данные;
* Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться super.clone() при переопределении метода clone();
* Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.

**38. Правила переопределения метода Object.clone()?**

Ответ: Метод clone() в Java используется для клонирования объектов. Т.к.  Java работает с объектами с помощью ссылок, то простым присваиванием  тут не обойдешься, ибо в любом случае копируется лишь адрес, и мы получаем две ссылки на один и тот же объект, а не то, что нам нужно. clone() действует как конструктор копирования. Обычно он вызывает метод super.clone().

Object.clone() кидает исключение CloneNotSupportedException, если вы пытаетесь клонировать объект не реализующий интерфейс Cloneable.

Метод clone() несовместим с final полями. Если вы попытаетесь клонировать final поле, то компилятор остановит вас.

![](https://4.bp.blogspot.com/-kNerO5PAWMI/V52kxm5A_fI/AAAAAAAAA_U/sh1UHOUbMyEYikGPvbMM-X_U_QZqQCEGgCEw/s1600/q040_p03.jpg)
![](https://3.bp.blogspot.com/-4jznYjVR3CE/V52lLdqcWyI/AAAAAAAAA_Q/c1UgZdztQvwZFi6S4iwGOeAMl7dqudHlQCLcB/s1600/q040_p04.jpg)

**39. Что такое конструктор по умолчанию?**

Ответ: В Java, если нет явным образом определенных конструкторов в классе, то компилятор использует  конструктор по умолчанию, определенный неявным образом. Конструктор по умолчанию - простая конструкция, которая сводится  к созданию для типа конструктора без параметров.

Если производный класс не вызывает явным образом конструктор базового класса(super() в первой строчке), то конструктор по умолчанию вызывается неявно. Если базовый класс не имеет конструктора по умолчанию, то это считается ошибкой.

**40. Где и как вы можете испоьлзовать закрытый конструктор?**

Ответ: Например, в качестве паттерна проектирования Singleton. Сделать конструктор класса (конструктор по-умолчанию) приватным (чтобы доступ к нему был закрыть за пределами класса, тогда он не сможет возвращать новые объекты)

``` java
public class LazyInitializedSingleton {
    private static LazyInitializedSingleton instance;
        private LazyInitializedSingleton(){}
        public static LazyInitializedSingleton getInstance(){ // #3
        if(instance == null){		//если объект еще не создан
            instance = new LazyInitializedSingleton();	//создать новый объект
        }
        return instance;		// вернуть ранее созданный объект
    }
}
```

**41. Опишите метод Object.finalize()?**

Ответ: Метод обеспечивает механизм, который является аналогичным  использованию деструкторов в С++, который может использоваться для того, чтобы произвести процесс очистки перед возвращением управления ОС. Применяя метод finalize(), можно определять специальные действия, который будут выполняться тогад, когда объект будет использоваться сборщиком мусора. В классе Object о ничего не делает, однако в классе-наследнике позволяет описать все действия, необходимые для корректного удаления объекта, такие как закрытия соединения с БД, сетевых соединений, снятие блокировок на файлы и тд. В обычным режиме напрямую этот метод вызывать не нужно, он отработает автоматически.

**42. Чем отличаются слова final, finally, finalize?**

Ответ: final - нельзя наследоваться от final класса; нельзя переопределить final метод; нельзя изменить значение final поля.

finally - используется при обработки ошибок, вызывается всегда, даже если произошла ошибка; удобно использовать при освобождении ресурсов.

finalize - вызывается перед тем, как свобщик мусора будет проводить освобождение памяти.











